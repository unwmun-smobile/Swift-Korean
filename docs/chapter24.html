<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>제네릭스 (Generics) · Swift 가이드</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&gt; Translator: Hoon H. (Eonil, drawtree@gmail.com)"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="제네릭스 (Generics) · Swift 가이드"/><meta property="og:type" content="website"/><meta property="og:url" content="https://unwmun-smobile.github.io/Swift-Korean/index.html"/><meta property="og:description" content="&gt; Translator: Hoon H. (Eonil, drawtree@gmail.com)"/><meta property="og:image" content="https://unwmun-smobile.github.io/Swift-Korean/img/swift.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://unwmun-smobile.github.io/Swift-Korean/img/swift.png"/><link rel="shortcut icon" href="/Swift-Korean/img/swift.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/Swift-Korean/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/Swift-Korean/"><img class="logo" src="/Swift-Korean/img/swift.png" alt="Swift 가이드"/><h2 class="headerTitleWithLogo">Swift 가이드</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/Swift-Korean/docs/chapter1.html" target="_self">Docs</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>LANGUAGE GUIDE</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">WELCOME TO SWIFT</h3><ul><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter1.html">Swift에 대해서 (About Swift)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter2.html">Swift 둘러보기 (Swift Tour)</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">LANGUAGE GUIDE</h3><ul><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter3.html">기초 다지기 (The Basics)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter4.html">기본 연산자 (Basic Operators)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter5.html">문자열과 문자 (Strings and Characters)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter6.html">컬렉션 타입 (Collection Types)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter7.html">흐름 제어  (Control Flow)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter8.html">함수 (Functions)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter9.html">클로저 (Closures)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter10.html">열거형 (Enumerations)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter11.html">클래스와 구조체 (Classes and Structures)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter12.html">속성 (Properties)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter13.html">메서드 (Methods)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter14.html">서브스크립트 (Subscripts)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter15.html">상속 (Inheritance)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter16.html">초기화 (Intialization)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter17.html">해제 (Deinitialization)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter18.html">자동 참조 계수 (Automatic Reference Counting)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter19.html">옵셔널 체인 (Optional Chaining)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter20.html">타입 변환 (Type Casting)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter21.html">중첩 타입 (Nested Types )</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter22.html">확장 (Extensions)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter23.html">프로토콜</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/Swift-Korean/docs/chapter24.html">제네릭스 (Generics)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter25.html">고급 연산자 (Advanced Operators)</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">LANGUAGE REFERENCE</h3><ul><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter26.html">언어 레퍼런스에 대하여 (About the Language Reference)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter27.html">언어 구조 (Lexcial Structure)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter28.html">타입 (Types)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter29.html">익스프레션 (Expressions)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter30.html">스테이트먼트 (Statements)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter31.html">선언 (Declarations)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter32.html">속성 (Attributes)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter33.html">패턴 (Patterns)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter34.html">제너릭 매개변수와 인자 (Generic Parameters and Arguments)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter35.html">문법 요약(Summary of the Grammar)</a></li></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">제네릭스 (Generics)</h1></header><article><div><span><blockquote>
<p>Translator: Hoon H. (Eonil, <a href="mailto:drawtree@gmail.com">drawtree@gmail.com</a>)</p>
</blockquote>
<p><em>제네릭 코드</em>는 정의된 요구사항에 따라 유연하고 재사용 가능한 함수들을 쓸 수 있도록 해줍니다. 반복을 피하고 의도를 명확하고 추상적으로 나타낼 수 있는 코드를 쓸 수 있습니다.</p>
<p>제네릭스는 Swift의 가장 강력한 기능 중 하나이며, Swift 기본 라이브러리의 많은 부분이 제네릭 코드로 만들어져 있습니다. 눈치채지 못했을 수도 있지만, 사실 제네릭스는 이 Language Guide에 이미 전반적으로 사용되고 있습니다. 예를 들어, Swift의 <code>Array</code>와 <code>Dictionary</code> 타입들은 모두 제네릭 타입입니다. <code>Int</code> 값을 담는 배열이나 <code>String</code> 값을 담는 배열을 만들 수 있습니다. 사실 어떤 타입의 배열든지 만들 수 있습니다. 비슷하게, 특정 형식의 값을 담는 사전(dictionary)도 만들 수 있으며, 선택 가능한 타입에는 어떤 제한도 없습니다.</p>
<h2><a class="anchor" aria-hidden="true" id="제네릭이-해결하는-문제-the-problem-that-generics-solve"></a><a href="#제네릭이-해결하는-문제-the-problem-that-generics-solve" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>제네릭이 해결하는 문제 (The Problem That Generics Solve)</h2>
<p>여기에 두 개의 <code>Int</code>값을 교체하는 <code>swapTwoInts</code>라는 일반적인 비-제네릭 함수가 있습니다.</p>
<pre><code class="hljs">    func swapTwoInts(inout <span class="hljs-selector-tag">a</span>: Int, inout <span class="hljs-selector-tag">b</span>: Int) {
        let temporaryA = <span class="hljs-selector-tag">a</span>
        <span class="hljs-selector-tag">a</span> = <span class="hljs-selector-tag">b</span>
        <span class="hljs-selector-tag">b</span> = temporaryA
    }
</code></pre>
<p>이 함수는 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-XID_226">In-Out Parameters</a>에 설명된 대로 두 값을 서로 바꾸기 위해 in-out 패러미터를 사용합니다.</p>
<p><code>swapTwoInts</code> 함수는 <code>b</code>의 원본값을 <code>a</code>로, <code>a</code>의 원본 값을 <code>b</code>로 바꾸어 넣습니다. 두 개의 <code>Int</code> 변수들에 있는 값들을 바꾸기 위해 이 함수를 호출할 수 있습니다.</p>
<pre><code class="hljs">    var someInt = 3
    var anotherInt = 107
    swapTwoInts(&amp;someInt, &amp;anotherInt)
    println("someInt <span class="hljs-keyword">is</span> <span class="hljs-keyword">now</span> \(someInt), <span class="hljs-keyword">and</span> anotherInt <span class="hljs-keyword">is</span> <span class="hljs-keyword">now</span> \(anotherInt)")
    // prints "someInt <span class="hljs-keyword">is</span> <span class="hljs-keyword">now</span> 107, <span class="hljs-keyword">and</span> anotherInt <span class="hljs-keyword">is</span> <span class="hljs-keyword">now</span> 3"
</code></pre>
<p>해당 <code>swapTwoInts</code> 함수는 유용하지만, 오직 <code>Int</code> 값만 사용할 수 있습니다. 만약 두 개의 <code>String</code>값이나, 두 개의 <code>Double</code> 값을 바꾸려면 <code>swapTwoStrings</code>이나 <code>swapTwoDoubles</code>같은 함수를 더 작성해야 합니다.</p>
<pre><code class="hljs">        func swapTwoStrings(inout <span class="hljs-selector-tag">a</span>: String, inout <span class="hljs-selector-tag">b</span>: String) {
        let temporaryA = <span class="hljs-selector-tag">a</span>
        <span class="hljs-selector-tag">a</span> = <span class="hljs-selector-tag">b</span>
        <span class="hljs-selector-tag">b</span> = temporaryA
    }
     
    func swapTwoDoubles(inout <span class="hljs-selector-tag">a</span>: Double, inout <span class="hljs-selector-tag">b</span>: Double) {
        let temporaryA = <span class="hljs-selector-tag">a</span>
        <span class="hljs-selector-tag">a</span> = <span class="hljs-selector-tag">b</span>
        <span class="hljs-selector-tag">b</span> = temporaryA
    }
</code></pre>
<p>이제 아마 <code>swapTwoInts</code>와 <code>swapTwoStrings</code>, <code>swapTwoDoubles</code>의 본체가 똑같다는 것을 눈치챘을 것입니다. 유일한 차이는 그들이 받아들이는(<code>Int</code>와 <code>String</code>, <code>Double</code>) 값의 타입입니다.</p>
<p>어떤 형식의 값이든 바꿀 수 있는 함수를 쓴다면 훨씬 더 유용하고, 더 유연하게 생각될 것입니다. 이런 종류의 문제가 바로 제네릭이 해결할 수 있는 문제입니다. (제네릭 버전의 이 함수들은 아래에 정의되어 있습니다)</p>
<blockquote>
<p>노트
이 모든 세 함수에서 <code>a</code>와 <code>b</code>의 타입은 서로 같도록 정의되어 있습니다. 만약 <code>a</code>와 <code>b</code>의 타입이 같지 않다면 두 값을 바꾸는 것은 불가능할 것입니다. Swift는 타입-안전 언어이기에 (예를 들어) <code>String</code> 타입의 변수와 <code>Double</code> 타입의 변수를 서로 바꾸도록 지원하지 않습니다. 그런 시도는 컴파일-타임 에러를 생성합니다.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="제네릭-함수들-generic-functions"></a><a href="#제네릭-함수들-generic-functions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>제네릭 함수들 (Generic Functions)</h2>
<p>제네릭 함수들은 어떤 타입과도 같이 동작합니다. 여기에 <code>swapTwoValues</code>라 불리는, 위에 언급된 <code>swapTwoInts</code> 함수의 제네릭 버전이 있습니다:</p>
<pre><code class="hljs">func swapTwoValues&lt;T&gt;(inout <span class="hljs-selector-tag">a</span>: T, inout <span class="hljs-selector-tag">b</span>: T) {
  let temporaryA = <span class="hljs-selector-tag">a</span>
  <span class="hljs-selector-tag">a</span> = <span class="hljs-selector-tag">b</span>
  <span class="hljs-selector-tag">b</span> = temporaryA
}
</code></pre>
<p><code>swapTwoValues</code> 함수의 본체는 <code>swapTwoInts</code> 함수와 같습니다. 하지만, <code>swapTwoValues</code> 함수의 첫줄은 <code>swapTwoInts</code>와 약간 다릅니다. 여기에 첫 줄의 비교가 있습니다:</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swapTwoInts</span><span class="hljs-params">(<span class="hljs-keyword">inout</span> a: Int, <span class="hljs-keyword">inout</span> b: Int)</span></span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swapTwoValues</span>&lt;T&gt;<span class="hljs-params">(<span class="hljs-keyword">inout</span> a: T, <span class="hljs-keyword">inout</span> b: T)</span></span>
</code></pre>
<p>제네릭 버전의 함수는 (<code>Int</code>나 <code>String</code>, <code>Double</code>같은) 실제 타입 이름 대신 <em>placeholder</em> 타입 이름을 사용합니다. (여기에서는 <code>T</code>) placeholder 타입 이름은 <code>T</code>가 되어야 하는 타입이 어떤 것인지 말하지 않지만, <code>a</code>와 <code>b</code>가 같은 타입이어야 <em>한다</em>는 것을 말합니다. <code>T</code>의 자리에 사용될 실제 타입은 <code>swapTwoValues</code> 함수가 호출될 때마다 결정될 것입니다.</p>
<p>다른 차이점은 제네릭 버전의 <code>swapTwoValues</code> 함수 정의에서는 함수 이름(<code>swapTwoValues</code>) 뒤에 placeholder 타입 이름(<code>T</code>)이 꺽쇠(<code>&lt;T&gt;</code>) 안에 따라온다는 것입니다. 꺽쇠(angle bracket)는 Swift에게 <code>swapTwoValues</code> 함수 정의 안에 있는 <code>T</code>는 placeholder 타입이라는 것을 알려줍니다. <code>T</code>가 placeholder 타입이므로, Swift는 <code>T</code>라는 실제 타입을 찾지 않습니다.</p>
<p><code>swapTwoValues</code> 함수는 <em>어떤</em> 타입의 두 값이든 사용할 수 있다는 것을 제외하면 이제 <code>swapTwoInts</code> 함수와 똑같이 호출될 수 있습니다. 단, 두 값의 타입은 서로 같아야 합니다. 매번 <code>swapTwoValues</code>이 호출될 때마다 함수에 전달된 값의 타입에 따라 <code>T</code>에 사용될 타입이 추정됩니다.</p>
<pre><code class="hljs">    <span class="hljs-built_in">var</span> someInt = <span class="hljs-number">3</span>
    <span class="hljs-built_in">var</span> anotherInt = <span class="hljs-number">107</span>
    swapTwoValues(&amp;someInt, &amp;anotherInt)
    // someInt is <span class="hljs-built_in">now</span> <span class="hljs-number">107</span>, <span class="hljs-built_in">and</span> anotherInt is <span class="hljs-built_in">now</span> <span class="hljs-number">3</span>
     
    <span class="hljs-built_in">var</span> someString = <span class="hljs-string">"hello"</span>
    <span class="hljs-built_in">var</span> anotherString = <span class="hljs-string">"world"</span>
    swapTwoValues(&amp;someString, &amp;anotherString)
    // someString is <span class="hljs-built_in">now</span> <span class="hljs-string">"world"</span>, <span class="hljs-built_in">and</span> anotherString is <span class="hljs-built_in">now</span> <span class="hljs-string">"hello"</span>
</code></pre>
<blockquote>
<p>노트
위에 정의된 <code>swapTwoValues</code> 함수는 Swift 표준 라이브라리에 있는 제네릭 버전 <code>swap</code> 함수에서 비롯되었습니다. 이 함수는 자동으로 앱 코드에 사용 가능합니다. <code>swapTwoValues</code>의 기능이 필요하다면 스스로 이 기능을 작성하기보다는 Swift에 미리 정의된 <code>swap</code> 함수를 쓰기 바랍니다.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="타입-패러미터-type-parameters"></a><a href="#타입-패러미터-type-parameters" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>타입 패러미터 (Type Parameters)</h2>
<p>위의 <code>swapTwoValues</code> 예시에서 placeholder 타입 <code>T</code>는 <code>타입 패러미터</code>의 한 예시입니다. 타입 패러미터는 함수 이름 바로 뒤에 (<code>&lt;T&gt;</code>같이) 꺽쇠 쌍 안에 있으며, 하나의 placeholder 타입을 지정하고 이름을 붙입니다.</p>
<p>일단 한 번 지정되면, 타입 패러미터는 (<code>swapTwoValues</code> 함수의 <code>a</code>나 <code>b</code> 패러미터들같이) 함수의 패러미터나, 리턴 타입 또는 함수 안에서의 타입 표시(annotation)에 사용될 수 있습니다. 타입 패러미터로 표현된 placeholder 타입은 매번 함수가 호출될 때마다 <em>실제</em> 타입으로 바뀌집니다. (위의 <code>swapTwoValues</code> 예시에서는 처음 함수 호출에서는 <code>T</code>가 <code>Int</code>로, 두번째 호출에서는 <code>String</code>으로 바뀌었습니다.</p>
<p>꺽쇠 안에 쉼표로 구분된 여러개의 타입 패러미터를 써서 하나 이상의 타입 패러미터들을 제공할 수 있습니다.</p>
<h2><a class="anchor" aria-hidden="true" id="타입-패러미터-이름짓기-naming-type-parameters"></a><a href="#타입-패러미터-이름짓기-naming-type-parameters" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>타입 패러미터 이름짓기 (Naming Type Parameters)</h2>
<p>제네릭 함수나 제네릭 타입이 하나의 placeholder 타입(위의 <code>swapTwoValues</code> 제네릭 함수나 <code>Array</code>같이 하나의 타입만 저장하는 제네릭 컬렉션)만 참조하는 간단한 경우, 타입 패러미터 이름에는 전통적으로 단일 문자 <code>T</code>를 사용합니다만, 패러미터 이름으로는 어떤 유효한 식별자든지 사용될 수 있습니다.</p>
<p>여러개의 패러미터를 지닌 좀 더 복잡한 제네릭 함수들이나 제네릭 타입들을 정의한다면, 좀 더 설명적인 타입 이름을 제공하는 것이 더 유용할 것입니다. 예를 들어, Swift의 <code>Dictionary</code> 타입은 각각 키와 값을 위한 두 개의 패러미터들을 갖고 있습니다. 만약 <code>Dictionary</code>을 스스로 작성해야 한다면 해당 타입 패러미터의 목적을 기억히기 쉽게 하기 위해 <code>KeyType</code>와 <code>ValueType</code>같은 이름을 사용하고 싶을 것입니다.</p>
<blockquote>
<p>노트
값이 아닌 타입을 위한 placeholder임을 표시하기 위해, 타입 패러미터 이름은 항상 <code>UpperCamelCase</code>로 지정하세요. (예:  <code>T</code>, <code>KeyType</code>)</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="제네릭-타입들-generic-types"></a><a href="#제네릭-타입들-generic-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>제네릭 타입들 (Generic Types)</h2>
<p>Swift는 제네릭 함수는 물론, <em>제네릭 타입</em>도 제공합니다. 이들은 <code>Array</code>나 <code>Dictionary</code>와 비슷하게 어떤 타입과도 동작하는 사용자-지정 클래스, 구조체, 열거형들입니다.</p>
<p>이 섹션에서는 어떻게 <code>Stack</code>이라는 제네릭 컬렉션 타입을 만드는지를 보여줍니다. 스택은 배열과 비슷한 하나의 정렬된 값 집합이지만, Swift의 <code>Array</code> 타입보다는 좀 더 제한된 연산만 사용 가능합니다. 배열은 배열의 어떤 위체에나 새로운 아이템이 추가되거나 삭제되도록 지원합니다. 하지만 스택은 컬렉션의 끝에 추가하는 것만 허용합니다. (새 값을 스택에 <em>push</em>한다는 표현으로 알려져 있습니다.) 비슷하게 스택은 컬렉션의 끝에 있는 아이템만 삭제하도록 허용합니다. (값을 스택에서 <em>pop</em>한다는 표현으로 알려져 있습니다)</p>
<blockquote>
<p>노트
스택 컨셉은 네비게이션 계층 상에서 뷰-제어기를 모델링하기 위해 <code>UINavigationController</code> 클래스에 사용되었습니다. 하나의 뷰-제어기를 네비게이션 스택에 추가(또는 push)하기 위해 <code>UINavigationController</code> 클래스의 <code>pushViewController:animated:</code> 메서드를 호출하거나 , 하나의 뷰-제어기를 네비게이션 스택에서 삭제(또는 pop)하기 위해 <code>popViewControllerAnimated:</code> 메서드를 호출할 수 있습니다. 스택은 컬렉션에서 엄격한 &quot;후입선출(last in, first oout)&quot; 방식을 관리할 때 유용합니다.</p>
</blockquote>
<p>아래 그림은 스택의 push/pop 동작을 보여줍니다.</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushPop_2x.png" alt="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushPop_2x.png"></p>
<ol>
<li>스택에 현재 새 개의 값이 있습니다.</li>
<li>네번째 값이 스택의 최상위로 &quot;push&quot;되었습니다.</li>
<li>스택이 이제 네 개의 값을 갖고 있습니다. 최신 값의 최상위에 있습니다.</li>
<li>스택의 최상위 아이템이 삭제되었습니다. (또는 &quot;pop&quot;)</li>
<li>값을 pop한 후, 스택은 다시 세개의 값을 갖게 됩니다.</li>
</ol>
<p>여기 <code>Int</code> 값 스택으로 어떻게 비-제네릭 버전의 스택을 쓰는지 보여줍니다.</p>
<pre><code class="hljs">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IntStack</span> </span>{
        <span class="hljs-keyword">var</span> items = <span class="hljs-type">Int</span>[]()
        <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">push</span><span class="hljs-params">(item: Int)</span></span> {
            items.append(item)
        }
        <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Int</span> {
            <span class="hljs-keyword">return</span> items.removeLast()
        }
    }
</code></pre>
<p>해당 구조체는 스택에 값을 저장하기 위해 <code>items</code>라 불리는 <code>Array</code> 속성을 사용합니다. <code>Stack</code>은 스택에 값을 push하고 pop하기 위해 <code>push</code>와 <code>pop</code>이라는 두 개의 메서드를 제공합니다. 이 메서드들은 구조체의 <code>items</code> 배열을 수정(<em>mutate</em>)해야 하므로 <code>mutating</code>으로 표시되어 있습니다.</p>
<p>어쨌든, 위에 보여진 <code>IntStack</code> 타입은 <code>Int</code> 값들만 사용할 수 있습니다. 어떤 타입의 값이든 사용할 수 있는 제네릭 <code>Stack</code> 클래스를 정의할 수 있다면 아주 유용할 것입니다.</p>
<p>여기에 같은 코드의 제네릭 버전이 있습니다:</p>
<pre><code class="hljs">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
        <span class="hljs-keyword">var</span> items = <span class="hljs-type">T</span>[]()
        <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">push</span><span class="hljs-params">(item: T)</span></span> {
            items.append(item)
        }
        <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">T</span> {
            <span class="hljs-keyword">return</span> items.removeLast()
        }
    }
</code></pre>
<p>제네릭 버전의 <code>Stack</code>이 <code>Int</code> 타입 대신 placeholder 타입 패러미터 <code>T</code>를 사용하는 것 외에는 본질적으로는 비-제네릭 버전과 같음에 주목하세요. 이 타입 패러미터는 구조체 이름 바로 뒤에 꺽쇠 쌍(<code>&lt;T&gt;</code>)으로 둘러싸여 쓰여 있습니다.</p>
<p><code>T</code>는 나중에 제공될 &quot;어떤 타입 <code>T</code>&quot;를 위한 placeholder 이름을 정의합니다. 이 미래의 타입은 구조체 정의 어디에서나 &quot;<code>T</code>&quot;로 참조될 수 있습니다. 이 경우에는, <code>T</code>는 세 곳에서 placeholder로 쓰였습니다.</p>
<ul>
<li><code>T</code> 타입 값의 빈 배열로 초기화된  <code>items</code>이라 불리는 속성.</li>
<li><code>T</code> 타입이 되어야 하는 <code>item</code>이라는 하나의 패러미터를 가지는 <code>push</code>라는 메서드.</li>
<li><code>T</code> 타입 값을 반환하는 <code>pop</code> 메서드.</li>
</ul>
<p>초기화 문법으로 새 인스턴스를 만들 때, 개별 스택의 실제 타입을 타입 이름 뒤에 오는 꺽쇠 기호 안에 써서 <code>Array</code>나 <code>Dictionary</code>와 비슷하게 <code>Stack</code>의 인스턴스를 만들 수 있습니다.</p>
<pre><code class="hljs">    var stackOfStrings = Stack&lt;<span class="hljs-keyword">String</span>&gt;()
    stackOfStrings.<span class="hljs-keyword">push</span>(<span class="hljs-string">"uno"</span>)
    stackOfStrings.<span class="hljs-keyword">push</span>(<span class="hljs-string">"dos"</span>)
    stackOfStrings.<span class="hljs-keyword">push</span>(<span class="hljs-string">"tres"</span>)
    stackOfStrings.<span class="hljs-keyword">push</span>(<span class="hljs-string">"cuatro"</span>)
    <span class="hljs-comment">// the stack now contains 4 strings</span>
</code></pre>
<p>이 그림은 네 개의 값을 push한 뒤에 <code>stackOfStrings</code>가 어떻게 되는지를 보여지는지를 보여줍니다.</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushedFourStrings_2x.png" alt="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushedFourStrings_2x.png"></p>
<p>한 값을 pop하면 스택의 최상위에서 해당 값을 지우고 반환합니다. <code>&quot;cuatro&quot;</code>:</p>
<pre><code class="hljs">    <span class="hljs-built_in">let</span> fromTheTop = stackOfStrings.<span class="hljs-built_in">pop</span>()
    // fromTheTop <span class="hljs-built_in">is</span> <span class="hljs-built_in">equal</span> to <span class="hljs-string">"cuatro"</span>, <span class="hljs-keyword">and</span> the stack now contains <span class="hljs-number">3</span> strings
</code></pre>
<p>최상위 값을 pop한 뒤 스택은 이렇게 됩니다.</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPoppedOneString_2x.png" alt="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPoppedOneString_2x.png"></p>
<p><code>Stack</code>은 제네릭 타입이므로 <code>Array</code>나 <code>Dictionary</code>와 비슷하게 Swift의 어떤 타입과도 같이 사용될 수 있습니다.</p>
<h2><a class="anchor" aria-hidden="true" id="타입-제약-type-constraints"></a><a href="#타입-제약-type-constraints" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>타입 제약 (Type Constraints)</h2>
<p><code>swapTwoValues</code> 함수와 <code>Stack</code> 타입은 어떤 타입과도 같이 작동합니다. 하지만, 어떨 때는 제네릭 함수와 제네릭 타입에 같이 사용될 수 있는 <em>타입을 제약(type constraint)</em>하는 것이 더 유용합니다. 타입 제약은 타입 패러미터가 특정 클래스에서 상속되어야 한다거나 특정 프로토콜 또는 프로토콜 합성을 만족해야 한다거나 하는 것이 될 수 있습니다.</p>
<p>예를 들어, Swift의 <code>Dictionary</code> 타입은 사전 키로 사용될 수 있는 타입을 제한합니다. <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/CollectionTypes.html#//apple_ref/doc/uid/TP40014097-CH8-XID_143">Dictionaries</a>에 설명된대로, 사전 키의 타입은 반드시 <em>해시-가능(hashable)</em>해야 합니다. 이는 키가 자신을 유일하게 식별할 수 있는 방식을 제공해야 한다는 뜻입니다. <code>Dictionary</code>에서는 특정 키가 이미 등록되어 있는지 여부를 판별하기 위해 해시-가능한 키가 필요합니다. 이 요구사항이 없다면 <code>Dictionary</code>는 특정 키를 삽입해야 하는지 아니면 교체해야 하는지 여부를 알 수 없으며, 사전에서 특정 키로 값을 찾을 수도 없습니다.</p>
<p>이 요구사항은 <code>Dictionary</code>의 키 타입에 있는 타입 제약으로 강제됩니다. 해당 제약은 키가 반드시 Swift 기본 라이브러리에 정의된 특수 프로토콜인 <code>Hashable</code> 프로토콜을 따라야만 하도록 지정합니다. Swift의 모든 기본 타입들(<code>String</code>, <code>Int</code>, <code>Double</code>또는 <code>Bool</code>)은 기본적으로 해시-가능입니다.</p>
<p>사용자 지정 제네릭 타입을 만들 때, 독자적인 타입 제약을 정의할 수 있고, 이 제약들은 제네릭 프로그래밍의 강력함을 제공합니다. <code>Hashable</code>과 같은 추상 개념은 특정 타입 대신 개념적 특징을 제공합니다.</p>
<h3><a class="anchor" aria-hidden="true" id="타입-제약-문법-type-constraint-syntax"></a><a href="#타입-제약-문법-type-constraint-syntax" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>타입 제약 문법 (Type Constraint Syntax)</h3>
<p>타입 제약은 타입 패러미터 목록의 일부로 콜론으로 나눠진 클래스나 프로토콜 제약을 타입 패러미터의 이름 뒤에 써서 만듭니다. 타입 제약의 기본적인 문법은 아래에 나타나 있습니다. (제네릭 타입도 문법이 같습니다):</p>
<pre><code class="hljs">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">someFunction</span>&lt;T: SomeClass, U: SomeProtocol&gt;<span class="hljs-params">(someT: T, someU: U)</span></span> {
        <span class="hljs-comment">// function body goes here</span>
    }
</code></pre>
<p>위에 있는 가상의 함수는 두 개의 타입 패러미터를 갖고 있습니다. 첫번째 타입 패러미터 <code>T</code>는 <code>T</code>가 <code>SomeClass</code>의 서브클래스가 되도록 요구합니다. 두번째 패러미터 <code>U</code>는 <code>U</code>가 <code>SomeProtocol</code> 프로토콜을 준수(conform)하도록 요구합니다.</p>
<h3><a class="anchor" aria-hidden="true" id="타입-제약-활용-type-constraints-in-action"></a><a href="#타입-제약-활용-type-constraints-in-action" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>타입 제약 활용 (Type Constraints in Action)</h3>
<p>여기에 <code>findStringIndex</code>이라 불리는 비-제네릭 함수가 있습니다. 이 함수는 주어진 <code>String</code> 값의 배열에서 주어진 <code>String</code> 값을 찾아냅니다. <code>findStringIndex</code> 함수는 하나의 선택적(optional) <code>Int</code> 값을 반환하는데, 이는 해당 배열에서 찾아낸 처음으로 일치하는 문자열의 인덱스입니다. 일치하는 값이 없으면 <code>nil</code>을 반환합니다.</p>
<pre><code class="hljs">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findStringIndex</span><span class="hljs-params">(array: String[], valueToFind: String)</span></span> -&gt; <span class="hljs-type">Int</span>? {
        <span class="hljs-keyword">for</span> (index, value) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(array) {
            <span class="hljs-keyword">if</span> value == valueToFind {
                <span class="hljs-keyword">return</span> index
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }
</code></pre>
<p><code>findStringIndex</code> 함수는 문자열 배열 내부에서 문자열 값을 찾기 위해 사용될 수 있습니다:</p>
<pre><code class="hljs">    <span class="hljs-keyword">let</span> <span class="hljs-attr">strings</span> = [<span class="hljs-string">"cat"</span>, <span class="hljs-string">"dog"</span>, <span class="hljs-string">"llama"</span>, <span class="hljs-string">"parakeet"</span>, <span class="hljs-string">"terrapin"</span>]
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-attr">foundIndex</span> = findStringIndex(strings, <span class="hljs-string">"llama"</span>) {
        println(<span class="hljs-string">"The index of llama is \(foundIndex)"</span>)
    }
    // prints <span class="hljs-string">"The index of llama is 2"</span>
</code></pre>
<p>어쨌든,  배열에서 한 값을 찾아내는 원리는 문자열에만 유용한 것이 아닙니다. 문자열에 대한 언급을 어떤 타입 <code>T</code>로 바꿈으로서 같은 기능을 <code>findIndex</code>라 불리는 제네릭 함수로 쓸 수 있습니다.</p>
<p>여기 <code>findIndex</code>라 불리는 제네릭 버전의 <code>findStringIndex</code>를 예상해 볼 수 있습니다. 반환되는 타입이 그대로 <code>Int?</code>임에 주목하세요. 함수가 선택적 값이 아닌 선택적 인덱스를 반환하기 때문입니다. 하지만 주의하세요 — 이 함수는 컴파일이 되지 않습니다. 예시 다음에 그 이유를 설명합니다.</p>
<pre><code class="hljs">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findIndex</span>&lt;T&gt;<span class="hljs-params">(array: T[], valueToFind: T)</span></span> -&gt; <span class="hljs-type">Int</span>? {
        <span class="hljs-keyword">for</span> (index, value) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(array) {
            <span class="hljs-keyword">if</span> value == valueToFind {
                <span class="hljs-keyword">return</span> index
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }
</code></pre>
<p>이 함수는 위에 쓰여진대로는 컴파일이 안됩니다. 문제는 동등성[1] 검사(<code>if value == valueToFind</code>)에 있습니다. Swift의 모든 타입이 동등(equal to) 연산자(<code>==</code>)로 비교 가능한 것이 아닙니다. 만약 복잡한 데이터 구조를 위해 사용자-지정 클래스나 구조체를 만든다면 Swift는 어떻게 이들의 동등성을 검사할 수 있는지 생각해낼수가 없습니다. 때문에, 모든 가능한 타입 <code>T</code>에 대해 이러한 코드가 작동하도록 보증하는 것은 불가능하며, 컴파일을 시도하면 적절한 에러가 보고될 것입니다.</p>
<p>[1]: 역주: equality(<code>==</code>)는 <em>동등성</em>으로 identity(<code>===</code>)는 <em>정체성</em>으로 번역함. 자세한 것은 &quot;클래스와 구조체의&quot; 하위 항목 <a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-XID_105">클래스는 참조 타입입니다</a>에 있는 &quot;정체성(Identity) 참조.</p>
<p>하지만, 이것이 완전히 불가능하지는 않습니다. Swift 기본 라이브러리는 <code>Equatable</code>이라 불리는 프로토콜을 정의하는데, 이는 이를 준수하는 타입이 동등 연산자 <code>==</code>와 비등 연산자 <code>!=</code>을 정의하도록 요구합니다. 모든 Swift 기본 타입들은 자동으로 <code>Equatable</code> 프로토콜을 지원합니다.</p>
<p><code>Equatable</code>인 모든 타입은 동등 연산자를 지원하므로 안전하게 <code>findIndex</code> 함수와 같이 쓰일 수 있습니다. 함수를 정의할 때 이 사실을 표현하기 위해 타입 패러미터의 일부러 <code>Equatable</code> 제약을 써야 합니다.</p>
<pre><code class="hljs">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findIndex</span>&lt;T: Equatable&gt;<span class="hljs-params">(array: T[], valueToFind: T)</span></span> -&gt; <span class="hljs-type">Int</span>? {
        <span class="hljs-keyword">for</span> (index, value) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(array) {
            <span class="hljs-keyword">if</span> value == valueToFind {
                <span class="hljs-keyword">return</span> index
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }
</code></pre>
<p><code>findIndex</code>의 단일 타입 패러미터는 <code>T: Equatable</code>로 쓰여 있는데, 이는 &quot;<code>Equatable</code> 프로토콜을 준수하는 어떤 타입 <code>T</code>&quot;를 의미합니다.</p>
<p><code>findIndex</code> 함수는 이제 제대로 컴파일되며, <code>Double</code>이나 <code>String</code>같이 <code>Equatable</code>을 준수하는 어떤 타입이든 사용할 수 있습니다.</p>
<pre><code class="hljs">    let doubleIndex = findIndex([<span class="hljs-number">3.14159</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.25</span>], <span class="hljs-number">9.3</span>)
    <span class="hljs-comment">// doubleIndex is an optional Int with no value, because 9.3 is not in the array</span>
    let stringIndex = findIndex([<span class="hljs-string">"Mike"</span>, <span class="hljs-string">"Malcolm"</span>, <span class="hljs-string">"Andrea"</span>], <span class="hljs-string">"Andrea"</span>)
    <span class="hljs-comment">// stringIndex is an optional Int containing a value of 2</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="연관-타입-associated-types"></a><a href="#연관-타입-associated-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>연관 타입 (Associated Types)</h2>
<p>프로토콜을 정의할 때, 하나 이상의 <em>연관 타입(associated types)</em>을 정의하는 것이 유용할 때가 있습니다. 연관 타입은 프로토콜의 일부로 사용되는 placeholder 이름(또는 별칭(<em>alias</em>))을 제공합니다. 해당 연관 타입은 프로토콜이 실제로 채용(adopt)될때까지 특정되지 않습니다. 연관 타입은 <code>typealias</code> 키워드로 지정됩니다.</p>
<h3><a class="anchor" aria-hidden="true" id="연관-타입-활용-associated-types-in-action"></a><a href="#연관-타입-활용-associated-types-in-action" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>연관 타입 활용 (Associated Types in Action)</h3>
<p>여기에 <code>ItemType</code>이라는 연관 타입을 선언(declare)하는 <code>Container</code>라는 프로토콜 예시가 있습니다.</p>
<pre><code class="hljs">    <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Container</span> </span>{
        <span class="hljs-keyword">typealias</span> <span class="hljs-type">ItemType</span>
        <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">append</span><span class="hljs-params">(item: ItemType)</span></span>
        <span class="hljs-keyword">var</span> <span class="hljs-built_in">count</span>: <span class="hljs-type">Int</span> { <span class="hljs-keyword">get</span> }
        <span class="hljs-keyword">subscript</span>(i: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">ItemType</span> { <span class="hljs-keyword">get</span> }
    }
</code></pre>
<p><code>Container</code> 프로토콜은 모든 컨테이너가 제공해야 하는 세 자기 능력들을 정의합니다.</p>
<ul>
<li><code>append</code> 메서드로 새 아이템을 추가할 수 있어야 한다.</li>
<li><code>Int</code>값을 반환하는 <code>count</code> 속성으로 컨테이너에 있는 아이템의 수를 셀 수 있어야 한다.</li>
<li><code>Int</code> 인덱스 값을 사용하는 첨자(subscript)로 컨테이너 안의 개별 아이템을 얻을 수 있어야 한다.</li>
</ul>
<p>이 프로토콜은 아이템들이 컨테이너 내에 저장되는 방식이나, 아이템의 타입을 지정하지 않습니다. 이 프로토콜은 단지 어떤 타입이든 <code>Container</code>로 취급되기 위해 제공해야 하는 세 가지 요소를 정의할 뿐입니다. 이를 준수하는 타입은 이 세 가지 요구사항을 만족하는 한 추가적인 기능을 제공할 수 있습니다.</p>
<p><code>Container</code> 프로토콜을 준수하는 타입은 반드시 그들이 저장하는 값의 타입을 지정할 수 있어야 합니다. 특히, 바른 타입의 아이템들만이 컨테이너에 추가되고 첨자로 반환되도록 보증하는 것이 중요합니다.</p>
<p>이러한 요구사항들을 정의하기 위해 <code>Container</code> 프로토콜은 특정 컨테이너 타입에 대한 정보 없이도 컨테이너가 보유할 요소들의 타입을 아는 것이 중요합니다. <code>Container</code> 프로토콜은 <code>append</code> 메서드로 들어온 모든 값이 컨테이너의 요소 타입와 같은 타입이고, 첨자로 반환될 값도 컨테이너의 요소 타입과 같은 타입이라는 것을 지정해야 합니다.</p>
<p>이를 위해, <code>Container</code> 프로토콜은 <code>ItemType</code>이라는 연관 타입을 선언합니다. 이는 <code>typealias ItemType</code>로 쓰여집니다. 프로토콜은 <code>ItemType</code>이 어느 타입에 대한 별칭(alias)인지는 정의하지 않습니다 — 그 정보는 준수하는(conforming) 타입이 제공해야 합니다. 그럼에도 불구하고, <code>ItemType</code> 별칭은 모든 <code>Container</code>에 기대되는 행동양식을 강제하기 위해  <code>Container</code> 안에 있는 아이템들을 참조할 수 있는 방법을 제공하고, <code>append</code> 메서드와 첨자에 사용되는 타입을 정의합니다.</p>
<p>여기에 예전에 만든 비-제네릭 버전의 <code>IntStack</code> 타입이 <code>Container</code> 프로토콜을 준수하는 버전이 있습니다.</p>
<pre><code class="hljs">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IntStack</span>: <span class="hljs-title">Container</span> </span>{
        <span class="hljs-comment">// original IntStack implementation</span>
        <span class="hljs-keyword">var</span> items = <span class="hljs-type">Int</span>[]()
        <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">push</span><span class="hljs-params">(item: Int)</span></span> {
            items.append(item)
        }
        <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Int</span> {
            <span class="hljs-keyword">return</span> items.removeLast()
        }
        <span class="hljs-comment">// conformance to the Container protocol</span>
        <span class="hljs-keyword">typealias</span> <span class="hljs-type">ItemType</span> = <span class="hljs-type">Int</span>
        <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">append</span><span class="hljs-params">(item: Int)</span></span> {
            <span class="hljs-keyword">self</span>.push(item)
        }
        <span class="hljs-keyword">var</span> <span class="hljs-built_in">count</span>: <span class="hljs-type">Int</span> {
        <span class="hljs-keyword">return</span> items.<span class="hljs-built_in">count</span>
        }
        <span class="hljs-keyword">subscript</span>(i: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> {
            <span class="hljs-keyword">return</span> items[i]
        }
    }
</code></pre>
<p><code>IntStack</code> 타입은 <code>Container</code> 프로토콜의 모든 세 가지 요구사항을 구현하며, 이를 위해 개별적으로 <code>IntStack</code> 타입의 기존 기능들을 래핑합니다.</p>
<p>더 나아가, <code>IntStack</code>는 이 <code>Container</code> 구현에서 적절한 <code>ItemType</code>은 <code>Int</code> 타입이라는 것을 지정합니다.  이 <code>Container</code> 구현에서 <code>typealias ItemType = Int</code>라는 정의는 <code>ItemType</code>라는 추상 타입(abstract type)을 <code>Int</code>라는 구체 타입(concrete type)으로 바꾸어 줍니다.</p>
<p>Swift의 타입 추론 기능 덕분에, 실제로는 <code>ItemType</code>라는 구체 타입이 <code>Int</code> 타입이라는 것을 <code>IntStack</code> 정의 일부로 선언할 필요조차 없습니다. <code>IntStack</code>이 <code>Container</code> 프로토콜의 모든 요구사항을 준수하므로(conforms), Swift는 그냥 <code>append</code> 메서드의 <code>item</code> 패러미터와 첨자(subscript) 리턴 타입을 살펴보는 것만으로도 적절한 <code>ItemType</code>을 추정할 수 있습니다. 실제로, <code>typealias ItemType = Int</code> 줄을 위의 코드에서 지우더라도 모든것이 제대로 작동하는데, <code>ItemType</code>이 무슨 타입인지가 명백하기 때문입니다.</p>
<p>또한, 제네릭 <code>Stack</code> 타입이 <code>Container</code> 프로토콜을 준수하도록 만들수도 있습니다.</p>
<pre><code class="hljs">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span>&lt;<span class="hljs-title">T</span>&gt;: <span class="hljs-title">Container</span> </span>{
        <span class="hljs-comment">// original Stack&lt;T&gt; implementation</span>
        <span class="hljs-keyword">var</span> items = <span class="hljs-type">T</span>[]()
        <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">push</span><span class="hljs-params">(item: T)</span></span> {
            items.append(item)
        }
        <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">T</span> {
            <span class="hljs-keyword">return</span> items.removeLast()
        }
        <span class="hljs-comment">// conformance to the Container protocol</span>
        <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">append</span><span class="hljs-params">(item: T)</span></span> {
            <span class="hljs-keyword">self</span>.push(item)
        }
        <span class="hljs-keyword">var</span> <span class="hljs-built_in">count</span>: <span class="hljs-type">Int</span> {
        <span class="hljs-keyword">return</span> items.<span class="hljs-built_in">count</span>
        }
        <span class="hljs-keyword">subscript</span>(i: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">T</span> {
            <span class="hljs-keyword">return</span> items[i]
        }
    }
</code></pre>
<p>이번에는, placeholder 타입 패러미터 <code>T</code>가 <code>append</code> 메서드의 <code>item</code> 패러미터와 리턴, 그리고 첨자 타입으로 쓰였습니다. Swift는 <code>T</code>가 이 특정 컨테이너에서 <code>ItemType</code>에 적절한 타입임을 추정할 수 있습니다.</p>
<h3><a class="anchor" aria-hidden="true" id="연관-타입을-지정하도록-기존-타입을-확장하기-extending-an-existing-type-to-specify-an-associated-type"></a><a href="#연관-타입을-지정하도록-기존-타입을-확장하기-extending-an-existing-type-to-specify-an-associated-type" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>연관 타입을 지정하도록 기존 타입을 확장하기 (Extending an Existing Type to Specify an Associated Type)</h3>
<p><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-XID_355">Adding Protocol Conformance with an Extension</a>에 설명된대로 기존 타입에 특정 프로토콜을 준수(conformance)하도록 추가할 수 있습니다. 이는 연관 타입을 가진 프로토콜도 포함합니다.</p>
<p>Swift의 <code>Array</code> 타입은 이미 <code>append</code> 메서드와 <code>count</code> 속성, 그리고 <code>Int</code> 첨자를 제공합니다. 이 세 가지 능력들(capabilities)은 <code>Container</code> 프로토콜의 요구사항을 만족합니다. 이는 그냥 <code>Array</code>가 <code>Container</code>를 채용(adopt)한다고 선언하는 것만으로도 준수(conform)하게 됨을 의미합니다. 이것은 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-XID_357">Declaring Protocol Adoption with an Extension</a>에 설명된대로 빈 확장(extension)을 사용함으로써 가능합니다.</p>
<pre><code class="hljs">    extension <span class="hljs-keyword">Array</span>: Container {}
</code></pre>
<p>배열의 기존 <code>append</code> 메서드와 첨자는 Swift가 적절한 <code>ItemType</code> 타입을 추정할 수 있도록 해줍니다. 위에 있는 <code>Stack</code> 타입같이 말이죠. 이 확장을 정의한 후에는 <code>Array</code>를 <code>Container</code>로 사용할 수 있습니다.</p>
<h2><a class="anchor" aria-hidden="true" id="where절-where-clauses"></a><a href="#where절-where-clauses" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Where절 (Where Clauses)</h2>
<p><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-XID_244">타입 제약</a>에 설명된 타입 제약은 제네릭 함수나 타입에 사용된 타입 패러미터에 요구사항을 정의하게 해줍니다.</p>
<p>연관 타입에 이런 제약을 정의할 수 있다면 쓸모가 많을겁니다. 이는 타입 패러미터 목록의 일부로 <em>where절(where clauses)</em>을 정의하는 것으로 가능합니다. Where절은 연관 타입이 특정 프로토콜을 준수하거나 해당 특정 타입 패러미터가 연관 타입과 같도록 요구할 수 있게 해줍니다. Where절을 만들기 위해서는, <code>where</code> 키워드를 패러미터 타입 목록 바로 뒤에 쓰고, 하나 이상의 연관 타입 제약을 쓰고, 타입과 연관 타입간의 일치 관계를 하나 이상 쓰면 됩니다.</p>
<p>다음의 예시는 두 <code>Container</code> 인스턴스들이 동등한 아이템을 같은 순서로 보유하는지 여부를 검사하는 <code>allItemsMatch</code>이라는 제네릭 함수를 정의합니다. 이 함수는 모든 아이템이 동등하면 <code>true</code>를, 아니라면 <code>false</code>를 반환합니다.</p>
<p>두 컨테이너들은 같은 타입일 필요가 없지만 (물로, 같아도 됩니다) 보유하는 아이템들의 타입은 같아야 합니다. 이 요구사항은 타입 제약과 where절의 조합으로 표현됩니다.</p>
<pre><code class="hljs">    func allItemsMatch&lt;
        C1: Container, C2: Container
        where C1.ItemType == C2.ItemType, C1.ItemType: Equatable&gt;
        (someContainer: C1, anotherContainer: C2) -&gt; Bool {
            
            //<span class="hljs-built_in"> check </span>that both containers contain the same number of items
           <span class="hljs-built_in"> if </span>someContainer.count != anotherContainer.count {
               <span class="hljs-built_in"> return </span>false
            }
            
            //<span class="hljs-built_in"> check </span>each pair of items to see<span class="hljs-built_in"> if </span>they are equivalent
            for i in 0..someContainer.count {
               <span class="hljs-built_in"> if </span>someContainer[i] != anotherContainer[i] {
                   <span class="hljs-built_in"> return </span>false
                }
            }
            
            // all items match, so<span class="hljs-built_in"> return </span>true
           <span class="hljs-built_in"> return </span>true
            
    }
</code></pre>
<p>이 함수는 <code>someContainer</code>와 <code>anotherContainer</code>라 불리는 두 개의 인수를 받습니다. <code>someContainer</code> 인수는 <code>C1</code>의 타입이고, <code>anotherContainer</code> 인수는 <code>C2</code>의 타입입니다. <code>C1</code>과 <code>C2</code> 모두 함수가 호출될때 밝혀질 두 컨테이너 타입을 위한 placeholder 타입 패러미터입니다. 함수의 타입 패러미터 리스트는 두 타입 패러미터 목록에 다음 요구사항들을 추가합니다.</p>
<ul>
<li><code>C1</code>은 반드시 <code>Container</code> 프로토콜을 준수해야 합니다. (예: <code>C1: Container</code>)</li>
<li><code>C2</code>도 반드시 <code>Container</code> 프로토콜을 준수해야 합니다. (예: <code>C2: Container</code>)</li>
<li><code>C1</code>의 <code>ItemType</code>은 <code>C2</code>의 <code>ItemType</code>과 같아야 합니다. (예: <code>C1.ItemType == C2.ItemType</code>)</li>
<li><code>C1</code>의 <code>ItemType</code>은 <code>Equatable</code> 프로토콜을 준수해야 합니다. (예: <code>C1.ItemType: Equatable</code>)</li>
</ul>
<p>세번째와 네번째 요구사항들은 where절의 일부로 정의되었고, <code>where</code> 키워드 뒤에 함수의 타입 패러미터 목록의 일부로 따라옵니다.</p>
<p>이 요구사항들은:</p>
<ul>
<li><code>someContainer</code>는 <code>C1</code>의 컨테이너 타입입니다.</li>
<li><code>anotherContainer</code>는 <code>C2</code>의 컨테이너 타입입니다.</li>
<li><code>someContainer</code>와 <code>anotherContainer</code>는 같은 타입의 아이템들을 가집니다.</li>
<li><code>someContainer</code> 안에 있는 아이템들은 비등 연산자(<code>!=</code>)를 사용해 서로 다른지 여부를 검사할 수 있습니다.</li>
</ul>
<p>를 의미합니다. 세번째와 네번째 요구사항의 조합은 <code>anotherContainer</code>의 아이템들 또한 <code>!=</code> 연산자로 검사될 수 있음을 의미하는데, 왜냐면 그것들이 <code>someContainer</code>의 아이템 타입과 동일하기 때문입니다.</p>
<p>이 요구사항들은 두 개의 컨테이너 타입이 다른 경우에도 <code>allItemsMatch</code> 함수가 두 컨테이너들을 비교할 수 있게 해줍니다.</p>
<p><code>allItemsMatch</code> 함수는 컨테이너들이 같은 수의 아이템을 갖고 있는지부터 검사하는데, 아이템 수가 다르면 같다고 볼 수가 없기 때문입니다. 이 경우 함수는 <code>false</code>를 반환합니다.</p>
<p>이 검사가 끝난 후, 이 함수는 <code>someContainer</code> 안에 있는 모든 아이템들을 <code>for</code>-<code>in</code> 루프와 반폐쇄 범위 연산자(<code>..</code>)로 반복(iterate)합니다. 모든 아이템들에 대해, 이 함수는 <code>someContainer</code>의 아이템이 <code>anotherContainer</code>에 있는 대응 아이템과의 같은지(not equal) 여부를 검사합니다. 만약 둘이 다르면 두 컨테이너는 다른 것이고, 함수는 <code>false</code>를 반환합니다.</p>
<p>만약 저 루프가 다른 아이템을 찾지 못하고 종료된다면 두 컨테이너는 같은 것이고 함수는 <code>true</code>를 반환합니다.</p>
<p><code>allItemsMatch</code> 함수의 실제 모습은 이렇습니다.</p>
<pre><code class="hljs">    var stackOfStrings = Stack&lt;String&gt;()
    stackOfStrings.<span class="hljs-keyword">push</span>(<span class="hljs-string">"uno"</span>)
    stackOfStrings.<span class="hljs-keyword">push</span>(<span class="hljs-string">"dos"</span>)
    stackOfStrings.<span class="hljs-keyword">push</span>(<span class="hljs-string">"tres"</span>)
     
    var arrayOfStrings = [<span class="hljs-string">"uno"</span>, <span class="hljs-string">"dos"</span>, <span class="hljs-string">"tres"</span>]
     
    <span class="hljs-keyword">if</span> allItemsMatch(stackOfStrings, arrayOfStrings) {
        <span class="hljs-keyword">println</span>(<span class="hljs-string">"All items match."</span>)
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">println</span>(<span class="hljs-string">"Not all items match."</span>)
    }
    <span class="hljs-comment">// prints "All items match."</span>
</code></pre>
<p>위의 예시는 <code>String</code> 값들을 저장하기 위한 <code>Stack</code> 인스턴스를 만들, 새 개의 문자열을 스택에 추가(push)합니다. 위 예시는 스택과 동일한 세 문자열을 포함하는 리터럴로 초기화된 <code>Array</code> 인스턴스도 만듭니다. 스택과 배열은 다른 타입이지만, 이들은 둘 다 <code>Container</code> 프로토콜을 준수하며, 같은 타입의 아이템들을 가집니다. 그러므로 이 두 컨테이너들을 인수로 사용해 <code>allItemsMatch</code> 함수를 호출할 수 있습니다. 위의 예시에서는 <code>allItemsMatch</code> 함수가 두 컨테이너 내의 모든 아이템들이 같다고 정확하게 보고합니다.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/Swift-Korean/docs/chapter23.html">← 프로토콜</a><a class="docs-next button" href="/Swift-Korean/docs/chapter25.html">고급 연산자 (Advanced Operators) →</a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#제네릭이-해결하는-문제-the-problem-that-generics-solve">제네릭이 해결하는 문제 (The Problem That Generics Solve)</a></li><li><a href="#제네릭-함수들-generic-functions">제네릭 함수들 (Generic Functions)</a></li><li><a href="#타입-패러미터-type-parameters">타입 패러미터 (Type Parameters)</a></li><li><a href="#타입-패러미터-이름짓기-naming-type-parameters">타입 패러미터 이름짓기 (Naming Type Parameters)</a></li><li><a href="#제네릭-타입들-generic-types">제네릭 타입들 (Generic Types)</a></li><li><a href="#타입-제약-type-constraints">타입 제약 (Type Constraints)</a><ul class="toc-headings"><li><a href="#타입-제약-문법-type-constraint-syntax">타입 제약 문법 (Type Constraint Syntax)</a></li><li><a href="#타입-제약-활용-type-constraints-in-action">타입 제약 활용 (Type Constraints in Action)</a></li></ul></li><li><a href="#연관-타입-associated-types">연관 타입 (Associated Types)</a><ul class="toc-headings"><li><a href="#연관-타입-활용-associated-types-in-action">연관 타입 활용 (Associated Types in Action)</a></li><li><a href="#연관-타입을-지정하도록-기존-타입을-확장하기-extending-an-existing-type-to-specify-an-associated-type">연관 타입을 지정하도록 기존 타입을 확장하기 (Extending an Existing Type to Specify an Associated Type)</a></li></ul></li><li><a href="#where절-where-clauses">Where절 (Where Clauses)</a></li></ul></nav></div><footer class="nav-footer" id="footer"><a href="https://code.facebook.com/projects/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/Swift-Korean/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2018 Your Name or Your Company Name</section></footer></div></body></html>