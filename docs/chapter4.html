<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>기본 연산자 (Basic Operators) · Swift 가이드</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&gt; Translator : 해탈 (kimqqyun@gmail.com)"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="기본 연산자 (Basic Operators) · Swift 가이드"/><meta property="og:type" content="website"/><meta property="og:url" content="https://unwmun-smobile.github.io/Swift-Korean/index.html"/><meta property="og:description" content="&gt; Translator : 해탈 (kimqqyun@gmail.com)"/><meta property="og:image" content="https://unwmun-smobile.github.io/Swift-Korean/img/swift.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://unwmun-smobile.github.io/Swift-Korean/img/swift.png"/><link rel="shortcut icon" href="/Swift-Korean/img/swift.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/Swift-Korean/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/Swift-Korean/"><img class="logo" src="/Swift-Korean/img/swift.png" alt="Swift 가이드"/><h2 class="headerTitleWithLogo">Swift 가이드</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/Swift-Korean/docs/chapter1.html" target="_self">Docs</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>LANGUAGE GUIDE</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">WELCOME TO SWIFT</h3><ul><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter1.html">Swift에 대해서 (About Swift)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter2.html">Swift 둘러보기 (Swift Tour)</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">LANGUAGE GUIDE</h3><ul><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter3.html">기초 다지기 (The Basics)</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/Swift-Korean/docs/chapter4.html">기본 연산자 (Basic Operators)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter5.html">문자열과 문자 (Strings and Characters)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter6.html">컬렉션 타입 (Collection Types)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter7.html">흐름 제어  (Control Flow)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter8.html">함수 (Functions)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter9.html">클로저 (Closures)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter10.html">열거형 (Enumerations)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter11.html">클래스와 구조체 (Classes and Structures)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter12.html">속성 (Properties)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter13.html">메서드 (Methods)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter14.html">서브스크립트 (Subscripts)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter15.html">상속 (Inheritance)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter16.html">초기화 (Intialization)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter17.html">해제 (Deinitialization)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter18.html">자동 참조 계수 (Automatic Reference Counting)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter19.html">옵셔널 체인 (Optional Chaining)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter20.html">타입 변환 (Type Casting)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter21.html">중첩 타입 (Nested Types )</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter22.html">확장 (Extensions)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter23.html">프로토콜</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter24.html">제네릭스 (Generics)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter25.html">고급 연산자 (Advanced Operators)</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">LANGUAGE REFERENCE</h3><ul><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter26.html">언어 레퍼런스에 대하여 (About the Language Reference)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter27.html">언어 구조 (Lexcial Structure)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter28.html">타입 (Types)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter29.html">익스프레션 (Expressions)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter30.html">스테이트먼트 (Statements)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter31.html">선언 (Declarations)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter32.html">속성 (Attributes)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter33.html">패턴 (Patterns)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter34.html">제너릭 매개변수와 인자 (Generic Parameters and Arguments)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter35.html">문법 요약(Summary of the Grammar)</a></li></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">기본 연산자 (Basic Operators)</h1></header><article><div><span><blockquote>
<p>Translator : 해탈 (<a href="mailto:kimqqyun@gmail.com">kimqqyun@gmail.com</a>)</p>
</blockquote>
<p><em>연산자</em>는 값을 확인 변경 합치기 위해 사용하는 특수 기호나 문구입니다. 예를 들어 더하기 연산자(<code>+</code>)는 (<code>let i = 1 + 2</code>에서 쓰이는것 같이) 두 숫자를 더합니다.
더 복잡한 연산자에 대해 예를 들자면,  (<code>if enteredDoorCode &amp;&amp; passedRetinaScan</code>에서와 같이) 논리 AND 연산자 <code>&amp;&amp;</code>가 있고, <code>i</code>의 값을 <code>1</code>만큼 증가시키는 것을 축약해서 표현한 <code>++i</code> 증가 연산자가 있습니다.</p>
<p>Swift 는 대부분의 표준 C 연산자를 지원하며 일반적인 코딩 오류를 제거하는 몇가지 기능을 향상 시켰습니다. 할당연산자 (<code>=</code>)대신 항등 연산자(<code>==</code>)를 사용하는 실수를 방지하기 위해 값을 반환하지 않습니다.
산술연산자(<code>+</code> ,<code>-</code> ,<code>*</code>,<code>/</code> ,<code>%</code> 등)가 오버플로우를 감지하고 그들을 저장하는 유형의 허용된 값의 범위보다 크거나 작아서 발생하는 예기치 않은 결과를 방지 할 수 있습니다.
당신은 오버 플로우 연산자에 설명된대로 Swift의 오버플로우 연산자를 사용하여 오버플로 값을 선택할수 있습니다. 이것은 <a href="">Overflow Operaters</a> 에 설명되어 있습니다.</p>
<p>C 와 달리, Swift는 부동 소수점 숫자에 나머지 (<code>%</code>) 계산을 수행 할 수 있습니다. 또한 Swift는 C언어에는 없는 (<code>A..B</code>)와 (<code>A...B</code>)의  2가지의 범위 연산자를 제공합니다. 이 연산자들은 값의 범위를 표현하기 위한 연산자입니다.</p>
<p>이 장에서는 Swift의 일반적인 연산자를 설명합니다. 고급 연산자는 <a href="">고급 연산자(Advanced Operator)</a> 장에 있습니다, 그리고 사용자 정의 연산자를 정의하고 사용자 정의 형식에 대한 표준 연산자를 구현하는 방법에 대해 설명합니다.</p>
<h2><a class="anchor" aria-hidden="true" id="용어-teminology"></a><a href="#용어-teminology" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>용어 (Teminology)</h2>
<p>연산자는 단항, 이진, 그리고 삼항이 있습니다.</p>
<ul>
<li><em>단항</em> 연산자는 단일 대상에서 작동합니다. (예 <code>-a</code>) 단항 <em>전위</em> 연산자를 바로 앞에 나타내고, (예 <code>!b</code>) 단항 <em>후위</em> 연산자는 타겟이후에 즉시 나타납니다. (예 <code>i++</code>)</li>
<li>이항 연산자는 두 가지의 대상에 작동합니다. 이항연산자는 중위연산자이며 두 대상 사이에 나타납니다.  (예 <code>2 + 3</code>)</li>
<li>삼항 연산자는 세 가지 대상에 작동합니다. C 처럼 , Swift는 하나의 삼항연산자를 가지고 있습니다. 삼항 조건 연산자는 (<code>a ? b : c</code>) 입니다.</li>
</ul>
<p>연산자에 영향을 주는 값은 피연산자입니다. 식 <code>1 + 2</code>에을 보면 <code>+</code> 기호는 이항 연산자이며 두가지의 피연산자 값인 <code>1</code> 과 <code>2</code>입니다.</p>
<h2><a class="anchor" aria-hidden="true" id="할당-연산자"></a><a href="#할당-연산자" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>할당 연산자</h2>
<p>할당 연산자는 (<code>a = b</code>) 초기화자(initializes) 또는 <code>b</code> 의 값을 <code>a</code> 에 할당하는것입니다.</p>
<pre><code class="hljs">let <span class="hljs-selector-tag">b</span> = <span class="hljs-number">10</span>
<span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-number">5</span>
<span class="hljs-selector-tag">a</span> = <span class="hljs-selector-tag">b</span>
<span class="hljs-comment">// a 는 이제 10 과 같습니다.</span>
</code></pre>
<p>만약 오른쪽이 같은 여러 값을 가진 튜플의 경우에 그 요소는 한번에 여러개의 상수 또는 변수로 분해 될수있습니다.</p>
<pre><code class="hljs">let <span class="hljs-comment">(x, y)</span> = <span class="hljs-comment">(1, 2)</span>
<span class="hljs-comment">// x 는 1 과 같고 y 는 2 와 같다.</span>
</code></pre>
<p>C 와 Objective-C의 대입 연산자와는 달리, Swift의 대입 연산자 자체가 값을 반환하지 않습니다. 다음 구문은 유효하지 않습니다.</p>
<pre><code class="hljs"><span class="hljs-keyword">if</span> <span class="hljs-attr">x</span> = y {
    // <span class="hljs-attr">x</span> = y가 값을 반환하지 않기 때문에 이것은 유효하지 않다, 
}
</code></pre>
<p>위 구문이 유효하지 않은 이유는, 실수로 (<code>==</code>) 대신 (<code>=</code>) 연산자를 사용하는것을 방지하기 위해서입니다. <code>if x = y</code> 가 유효하지 않게 함으로써 Swift 코드에서 이러한 종류의 오류를 방지하는데 도움이 됩니다.</p>
<h2><a class="anchor" aria-hidden="true" id="산술-연산자"></a><a href="#산술-연산자" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>산술 연산자</h2>
<p>Swift 는 4가지의 산술연산자가 모든 숫자 타입을 지원합니다.</p>
<ul>
<li>덧셈 (<code>+</code>)</li>
<li>뺼셈 (<code>-</code>)</li>
<li>곱셈 (<code>*</code>)</li>
<li>나눗셈 (<code>/</code>)</li>
</ul>
<pre><code class="hljs"><span class="hljs-symbol">1 </span>+ <span class="hljs-number">2</span>           // <span class="hljs-number">3</span>
<span class="hljs-symbol">5 </span>- <span class="hljs-number">3</span>           // <span class="hljs-number">2</span>
<span class="hljs-symbol">2 </span>* <span class="hljs-number">3</span>           // <span class="hljs-number">6</span>
<span class="hljs-number">10.0</span> / <span class="hljs-number">2.5</span>      // <span class="hljs-number">4.0</span>
</code></pre>
<p>C 및 Objective-C의 산술 연산자와는 달리 Swift 산술 연산자는 값이 기본적으로 오버플로우하는것을 허용하지 않는다. Swift 오버플로우 연산자(<code>a &amp;+ b</code>와 같은)를 사용하여 값 오버플로 동작을 선택할 수있습니다. <a href="">Overflow Operators</a>를 참조하십시오.</p>
<p>또한 덧셈 연산자는 문자열을 지원합니다.</p>
<pre><code class="hljs"><span class="hljs-string">"hello, "</span> + <span class="hljs-string">"world"</span> <span class="hljs-regexp">//</span> <span class="hljs-string">"hello, world"</span> 와 같다
</code></pre>
<p>두 개의 <code>Character</code> 값이거나 하나는 <code>Character</code> 값 그리고 하나는 <code>String</code> 값일때 두 개를 함께 더해서 새로운 <code>String</code> 값을 만들 수 있습니다.</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> <span class="hljs-keyword">do</span><span class="hljs-variable">g:</span> Character = <span class="hljs-comment">"🐶🐶</span>
<span class="hljs-keyword">let</span> <span class="hljs-keyword">co</span><span class="hljs-variable">w:</span> Character = <span class="hljs-string">"🐮"</span>
<span class="hljs-keyword">let</span> dogCow = dog + cow
// dogCow <span class="hljs-keyword">is</span> equal <span class="hljs-keyword">to</span> <span class="hljs-string">"🐶🐮"</span>
</code></pre>
<p>이것에 대해선 <a href="">문자열과 문자(Concatenating Strings and Characters)</a>를 참조 바랍니다</p>
<h2><a class="anchor" aria-hidden="true" id="나머지-연산자"></a><a href="#나머지-연산자" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>나머지 연산자</h2>
<p>나머지 연산자는 (<code>a % b</code>) <code>b</code> 의 몇 배수가 <code>a</code>에 맞게 곱해지며 그리고 남아 있는 값을 반환합니다. (이는 <em>나머지</em> 라고 불립니다.)</p>
<blockquote>
<p>NOTE</p>
</blockquote>
<blockquote>
<p>나머지 연산자는 (<code>%</code>) 또한 <em>모듈로(modulo) 연산</em>으로 다른 언어에 알려져있다. 그러나 Swift에서의 동작은 음수를 의미한다. 엄격히 말하면, 모듈로 연산보다는 나머지 연산이다.</p>
</blockquote>
<p>여기에 나머지 연산의 동작이 어떻게 되는지 나와있습니다. <code>9 % 4</code>을 계산해보면, 당신은 첫번째로 <code>9</code>안에 몇 개의 <code>4</code>가 들어갈 수 있는지 알아낼 것이다.
<img src="https://raw.githubusercontent.com/lean-tra/Swift-Korean/master/images/remainderinteger_2x.png" alt="remainderinteger_2x.png"></p>
<p>당신은 <code>4</code>들을 <code>9</code>에 맞추었고 그리고 나머지는 <code>1</code>이다. (오렌지 색깔을 보라)</p>
<p>Swift에서는 이렇게 쓰여집니다.</p>
<pre><code class="hljs"><span class="hljs-symbol">9 </span>% <span class="hljs-number">4</span> // <span class="hljs-number">1</span>과 같다
</code></pre>
<p><code>a % b</code> 의 답을 측정해보면, <code>%</code> 연산자는 아래의 방정식을 계산하고, <code>remainder</code>를  반환합니다.</p>
<p><code>a</code> = (<code>b</code> x <code>배수</code>) + <code>나머지</code></p>
<p><code>배수</code>는 <code>a</code> 에 들어갈 <code>b</code>의 최대의 숫자입니다.</p>
<p><code>9</code> 와 <code>4</code>를 식에 대입 할경우</p>
<p><code>9</code> = (<code>4</code> × <code>2</code>) + <code>1</code></p>
<p><code>a</code> 의 값이 음수 일때도 같은 메소드가 지원되며 나머지 값이 음수가 나옵니다.</p>
<pre><code class="hljs"><span class="hljs-number">-9</span> % <span class="hljs-number">4</span> <span class="hljs-comment">// -1과 같다</span>
</code></pre>
<p><code>-9</code> 와 <code>4</code> 를 넣으면 다음과 같은 식이 나옵니다.</p>
<p><code>-9</code> = (<code>4</code> × <code>-2</code>) + <code>-1</code></p>
<p>나머지 값이 <code>-1</code>이 주어집니다.</p>
<p><code>b</code>가 음수일때 부호는 무시됩니다. 이 뜻은 <code>a % b</code> 와 <code>a % -b</code>는 항상 같은 대답을 주고 있다는 것을 의미합니다.</p>
<h2><a class="anchor" aria-hidden="true" id="부동-소수점-나머지-연산"></a><a href="#부동-소수점-나머지-연산" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>부동 소수점 나머지 연산</h2>
<p>C 와 Objective-C의 나머지 연산과는 달리, Swift의 나머지 연산은 부동 소수점 연산 또한 지원합니다.</p>
<pre><code class="hljs"><span class="hljs-symbol">8 </span>% <span class="hljs-number">2.5</span> // <span class="hljs-number">2.5</span>와 같음
</code></pre>
<p>예를 들어 <code>8</code>을 <code>2.5</code>로 나누었을때 <code>3</code>과 같으며 나머지는 <code>0.5</code>와 같습니다. 그리고 나머지 연산이 반환하는 값은 <code>Double</code> 타입의 <code>0.5</code> 입니다.
<img src="https://raw.githubusercontent.com/lean-tra/Swift-Korean/master/images/remainderfloat_2x.png" alt="remainderfloat_2x.png"></p>
<h2><a class="anchor" aria-hidden="true" id="증가연산자와-감소-연산자"></a><a href="#증가연산자와-감소-연산자" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>증가연산자와 감소 연산자</h2>
<p>C와 같이, Swift는 증가 연산자(<code>++</code>)와 감소 연산자(<code>--</code>)를 제공한다. 이것은 숫자 변수 <code>1</code>를 증가시키거나 감소시키는 축약형입니다. 정수형과 부동소수점형을 연산자와 같이 사용 가능합니다.</p>
<pre><code class="hljs"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">i</span> = <span class="hljs-number">0</span>
++<span class="hljs-selector-tag">i</span> <span class="hljs-comment">// i 는 이제 1과 같다</span>
</code></pre>
<p>만약 <code>++i</code> 호출마다 <code>i</code>의 값은 <code>1</code> 씩 증가됩니다. 기본적으로 <code>++i</code> 는 <code>i = i + 1</code> 의 약어입니다. 마찬가지로 <code>--i</code>를 <code>i = i - 1</code> 의 약어로 사용할 수 있습니다.</p>
<p><code>++</code> 와 <code>--</code> 기호는 전위연산자 또는 후위연산자로 사용이 가능합니다. <code>++i</code> 와 <code>++i</code>는 둘다<code>i</code>의 값을<code>1</code> 증가시키는 방법입니다. 비슷하게, <code>--i</code> 와 <code>i--</code>는 <code>i</code>의 값을 <code>1</code> 감소시키는 방법입니다.</p>
<p>이러한 수정연산자는 <code>i</code> 와 그리고 반환값 까지 변화시킵니다. 만약 <code>i</code>에 저장된 값을 증가 또는 감소 시킬 경우 반환값을 무시 할 수도 있습니다. 그러나 반환된 값을 사용할 경우, 당신은 다음과 같은 규칙에 따라 연산자의 전위연산자나 후위연산자를 사용하는지 여부에 따라 달라집니다.</p>
<ul>
<li>만약 변수 앞에 쓰여질 경우, 값이 증가한 후에 반환된다.</li>
<li>반약 변수 뒤에 쓰여질 경우, 값이 반환된 뒤에 증가된다.</li>
</ul>
<p>예제 코드 (For example:)</p>
<pre><code class="hljs"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-number">0</span>
let <span class="hljs-selector-tag">b</span> = ++<span class="hljs-selector-tag">a</span>
<span class="hljs-comment">// a 와 b 둘다 1과 같다.</span>
let c = a++
<span class="hljs-comment">// a 는 지금 2 입니다. 그러나 c는 이전의 값인 1이 이미 설정되어있습니다.</span>
</code></pre>
<p>위의 예제코드에서 <code>let b = ++a</code> 는 <code>a</code>를 반환하기 전에 <code>a</code>를 증가시킨다. 이 방법은 <code>a</code> 와 <code>b</code> 의 새로운 값이 동등한 이유이다.</p>
<p>그러나, <code>let c = a++</code> 는 <code>a</code>를 후에 반환한 뒤 <code>a</code>를 증가시킨다. 이 뜻은 <code>c</code>가 없은 값은 예전의 값인 <code>1</code>이며 <code>a</code>에게는 업데이트 된 <code>2</code>와 같습니다.</p>
<p><code>i++</code>의 특정동작을 필요로 하지 않는한,  <code>++i</code> 나 <code>--i</code>를 사용하는것이 좋습니다. 왜냐하면 그것은 모든 경우에 <code>i</code>를 결과를 반환하고 수정하는 예상된 동작을 가지기 때문입니다.</p>
<h2><a class="anchor" aria-hidden="true" id="단항-마이너스-연산자"></a><a href="#단항-마이너스-연산자" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>단항 마이너스 연산자</h2>
<p>숫자 값의 부호는 전위연산자 <code>-</code>를 사용하여 전환할 수 있다. 이것은 단항 마이너스 연산자로 알려진것입니다.</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> <span class="hljs-attr">three</span> = <span class="hljs-number">3</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">minusThree</span> = -three // minusThree equal -<span class="hljs-number">3</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">plusThree</span> = -minusThree // plus equal <span class="hljs-number">3</span>, <span class="hljs-literal">or</span> <span class="hljs-string">"minus minus        three"</span>
</code></pre>
<p>단항 마이너스 연산자는 공백없이 값 바로 앞에 추가됩니다.</p>
<h2><a class="anchor" aria-hidden="true" id="단항-플러스-연산자"></a><a href="#단항-플러스-연산자" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>단항 플러스 연산자</h2>
<p>단항 플러스 연산자(<code>+</code>)는 간단하게 값 앞에 추가되며 값을  변경하지 않고 값을 반환합니다.</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> <span class="hljs-attr">minusSix</span> = -<span class="hljs-number">6</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">alsoMinusSix</span> = +minusSix // alsoMinusSix equals -<span class="hljs-number">6</span>
</code></pre>
<p>플러스 연산자가 있음에도 불구하고 실제로 아무것도 하지 않지만, 당신은 또한 단항 마이너스 연산자를 사용하는 경우에 양수에 대한 코드대칭에 사용할 수 있습니다.</p>
<h2><a class="anchor" aria-hidden="true" id="복합-할당-연산자"></a><a href="#복합-할당-연산자" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>복합 할당 연산자</h2>
<p>C와 같이 Swift는 다른 작업에 할당(<code>=</code>)을 결합하는 복합 할당 연산자를 제공합니다. 한 예를 들어 덧셈 할당 연산자입니다 (<code>+=</code>):</p>
<pre><code class="hljs"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-number">1</span>
<span class="hljs-selector-tag">a</span> += <span class="hljs-number">2</span>
<span class="hljs-comment">// a 는 3과 같다</span>
</code></pre>
<p>표현식 <code>a += 2</code> 는 <code>a = a + 2</code> 의 축약형입니다. 효과적으로 한 연산자가 가산 및 할당이 동시에 결합과 작업이 됩니다.</p>
<blockquote>
<p>NOTE
복합 할당 연산자는 값을 반환하지 않습니다. 당신은 <code>let b = a += 2</code> 이러한 코드를 작성할수 없습니다. 예를 들어 이러한 코드는 위의 증가 및 감소 연산자와는 다릅니다.</p>
</blockquote>
<p>복합 할당 연산자의 전체 목록은 <a href="">Expressions</a> 에서 찾을 수 있습니다.</p>
<h2><a class="anchor" aria-hidden="true" id="비교-연산자"></a><a href="#비교-연산자" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>비교 연산자</h2>
<p>Swift는 C의 표준 비교연산자를 지원합니다.</p>
<ul>
<li>같음 연산자 (<code>a == b</code>)</li>
<li>같지 않음 연산자 (<code>a != b</code>)</li>
<li>보다 큰 (<code>a &gt; b</code>)</li>
<li>보다 작은(<code>a &lt; b</code>)</li>
<li>보다 크거나 같은 (<code>a &gt;= b</code>)</li>
<li>보다 작거나 같은 (<code>a &lt;= b</code>)</li>
</ul>
<blockquote>
<p>NOTE
Swift는 또한 두 개체 참조가 동일한 인스턴스 객체를 참조하고 있는지 여부를 테스트 하는 연산자를 지원합니다. (<code>===</code> 와 <code>!==</code>) 자세한 내용은 <a href="">Classes and Structures</a>를 참조하십시오.</p>
</blockquote>
<p>비교 연산자의 각 문장이 참인지 여부를 나타내는 <code>Bool</code> 값을 반환합니다 :</p>
<pre><code class="hljs"><span class="hljs-symbol">1 </span>== <span class="hljs-number">1</span>   // true, because <span class="hljs-number">1</span> is equal <span class="hljs-keyword">to</span> <span class="hljs-number">1</span>
<span class="hljs-symbol">2 </span>!= <span class="hljs-number">1</span>   // true, because <span class="hljs-number">2</span> is <span class="hljs-keyword">not</span> equal <span class="hljs-keyword">to</span> <span class="hljs-number">1</span>
<span class="hljs-symbol">2 </span>&gt; <span class="hljs-number">1</span>    // true, because <span class="hljs-number">2</span> is greater than <span class="hljs-number">1</span>
<span class="hljs-symbol">1 </span>&lt; <span class="hljs-number">2</span>    // true, because <span class="hljs-number">1</span> is less than <span class="hljs-number">2</span>
<span class="hljs-symbol">1 </span>&gt;= <span class="hljs-number">1</span>   // true, because <span class="hljs-number">1</span> is greater than <span class="hljs-keyword">or</span> equal <span class="hljs-keyword">to</span> <span class="hljs-number">1</span>
<span class="hljs-symbol">2 </span>&lt;= <span class="hljs-number">1</span>   // false, because <span class="hljs-number">2</span> is <span class="hljs-keyword">not</span> less than <span class="hljs-keyword">or</span> equal <span class="hljs-keyword">to</span> <span class="hljs-number">1</span>
</code></pre>
<p>비교 연산자는 종종 <code>if</code>문 같은 조건문에 사용됩니다 :</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> name == <span class="hljs-string">"world"</span>
<span class="hljs-keyword">if</span> name == <span class="hljs-string">"world"</span> {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"hello, world"</span>)
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"I'm sorry <span class="hljs-subst">\(name)</span>, but I don't recognize you"</span>)
}
<span class="hljs-comment">// prints "hello, world", because name is indeed equal to "world”</span>
</code></pre>
<p><code>if</code>에 대한 더 많은 정보는 <a href="">Control Flow</a>를 참조하기 바랍니다.</p>
<h2><a class="anchor" aria-hidden="true" id="삼항-조건-연산자"></a><a href="#삼항-조건-연산자" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>삼항 조건 연산자</h2>
<p>삼항 조건 연산자는 특별한 연산자와 세개의 파트로 이루어져있습니다.
식은 이러합니다. (<code>question ? answer1 : answer2</code>)
이 <code>question</code>을 기초로하여 참인지 거짓인지에 따라 두 식중 하나를 평가하기 위한 축약어입니다. 만약 <code>question</code> 이 참이면 <code>answer1</code>을 계산하고 값을 반환합니다; 그렇지 않으면 <code>answer2</code>를 계산하고 값을 반환합니다.</p>
<p>삼항 조건 연산자는 아래의 코드에 대한 단축 표현입니다.</p>
<pre><code class="hljs"><span class="hljs-keyword">if</span> question {
    answer1
} <span class="hljs-keyword">else</span> {
    answer2
}
</code></pre>
<p>이것은 테이블 행의 픽셀 높이를 계산하는 예제입니다. 행의 헤더가 있다면 컨텐츠의 높이가 50 픽셀이상이고 행의 헤더가 없다면 20픽셀 보다 큰것입니다.:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> <span class="hljs-attr">contentHeight</span> = <span class="hljs-number">40</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">hasHeader</span> = <span class="hljs-literal">true</span> 
<span class="hljs-keyword">let</span> <span class="hljs-attr">rowHeight</span> = contentHeight + (hasHeader ? <span class="hljs-number">50</span> : <span class="hljs-number">20</span>)
// rowHeight 는 <span class="hljs-number">90</span>과 같다
</code></pre>
<p>위의 예제코드는 아래 코드의 속기입니다.</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> <span class="hljs-attr">contentHeight</span> = <span class="hljs-number">40</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">hasHeader</span> = <span class="hljs-literal">true</span>
var <span class="hljs-attr">rowHeight</span> = contentHeight
<span class="hljs-keyword">if</span> hasHeader {
    <span class="hljs-attr">rowHeight</span> = rowHeight + <span class="hljs-number">50</span>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-attr">rowHeight</span> = rowHeight + <span class="hljs-number">20</span>
}
</code></pre>
<p>첫번째 예제의 삼항 조건 연산자의 사용은 <code>rowheight</code>에 단 한줄의 코드를 이용하여 올바른 값으로 설정될 수 있음을 의미합니다. 이것은 두 번째 예제코드보다 간결하고 그 값이 <code>if</code> 문 내에서 수정될 필요가 없기 떄문에 이것은 <code>rowheight</code>가 변수가 될 필요성이 없어집니다.</p>
<p>삼항 조건 연산자는 두 식의 어떤 결정을 고려하는것을 위해 효율적인 속기를 제공합니다. 그러나 삼항 조건 연산자는 주의해서 다뤄야 합니다. 남용하면 그 간결함은 읽기 어려운 코드로 이어질 수 있습니다. 하나의 복합 구문에 삼항 조건 연산자와 다중 인스턴스를 결합하는것을 피하십시오.</p>
<h2><a class="anchor" aria-hidden="true" id="범위-연산자"></a><a href="#범위-연산자" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>범위 연산자</h2>
<p>Swift는 두 개의 범위연산자를 지원하며 이 축약어는 값의 범위를 표현합니다.</p>
<h3><a class="anchor" aria-hidden="true" id="폐쇄-범위-연산자"></a><a href="#폐쇄-범위-연산자" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>폐쇄 범위 연산자</h3>
<p>폐쇄 범위 연산자(<code>a...b</code>)는 <code>a</code>에서 <code>b</code> 까지의 범위를 정의합니다. 그리고 <code>a</code>와 <code>b</code>의 값을 포함합니다.</p>
<p>폐쇄 범위 연산자는 <code>for-in</code> 루프와 같이 사용하고자 하는 값 범위에서 반복할때 폐쇄 범위 연산자는 유용합니다.</p>
<pre><code class="hljs"><span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>...<span class="hljs-number">5</span> {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"<span class="hljs-subst">\(index)</span> time 5 is <span class="hljs-subst">\(index * <span class="hljs-number">5</span>)</span>"</span>)
}
<span class="hljs-comment">// 1번쨰 반복 5 is 5</span>
<span class="hljs-comment">// 2번쨰 반복 5 is 10</span>
<span class="hljs-comment">// 3번쨰 반복 5 is 15</span>
<span class="hljs-comment">// 4번쨰 반복 5 is 20</span>
<span class="hljs-comment">// 5번쨰 반복 5 is 25</span>
</code></pre>
<p><code>for-in</code> 루프에 대해서는 <a href="">Control Flow</a> 항목을 참조하십시오</p>
<h3><a class="anchor" aria-hidden="true" id="반-폐쇄-범위-연산자"></a><a href="#반-폐쇄-범위-연산자" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>반 폐쇄 범위 연산자</h3>
<p>반 폐쇄 범위 연산자 (<code>a..b</code>)는 <code>a</code> 에서 <code>b</code> 로 실행되는 범위를 정의하지만 <code>b</code>가 포함되어 있지 않습니다. 처음 값은 포함하고 있지만 최종값은 아니기 때문에 반폐쇄라고 합니다.</p>
<p>반 폐쇄 범위는 특히 0을 기반으로한 리스트 또는 배열로 작업할때 유용합니다. 그것은 리스트의 길이(포함안되는)까지 계산하는데 유용합니다.</p>
<pre><code class="hljs">let names = [<span class="hljs-string">"Anna"</span>, <span class="hljs-string">"Alex"</span>, <span class="hljs-string">"Brian"</span>, <span class="hljs-string">"Jack"</span>]
let count = name<span class="hljs-selector-class">.count</span>
<span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>.<span class="hljs-selector-class">.count</span> {
    println(<span class="hljs-string">"Person \(i + 1) is called \(names[i]"</span>)
}
<span class="hljs-comment">// Person 1 is called Anna</span>
<span class="hljs-comment">// Person 2 is called Alex</span>
<span class="hljs-comment">// Person 3 is called Brian</span>
<span class="hljs-comment">// Person 4 is called Jack</span>
</code></pre>
<p>배열에는 4개의 항목이 포함되어있습니다. 하지만 반 폐쇄 범위기 때문에 <code>0..count</code> 는 단지 3까지만 카운트 합니다. (배열의 마지막 항목의 인덱스)
배열에 대해 더 참조하고 싶다면 <a href="">Arrays(배열)</a>을 참조하세요.</p>
<h2><a class="anchor" aria-hidden="true" id="논리-연산자"></a><a href="#논리-연산자" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>논리 연산자</h2>
<p>논리 연산자는 <code>true</code>와 <code>false</code> 불리언 논리 값을 수정하거나 결합합니다. Swift는 C 기반 언어의 세 가지 표준 논리 연산자를 지원합니다.</p>
<ul>
<li>NOT (<code>!a</code>)</li>
<li>AND (<code>a &amp;&amp; b</code>)</li>
<li>OR (<code>a || b</code>)</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="논리-not-연산자"></a><a href="#논리-not-연산자" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>논리 NOT 연산자</h2>
<p>논리 NOT 연산자(<code>!a</code>)는 불리언 논리 값인 <code>true</code> 값을 반전시키고 <code>false</code> 값은 <code>true</code> 가 됩니다.</p>
<p>논리 NOT 연산자는 전위 연산자입니다. 값 앞에 연산을 공백없이 즉시 표현 할 수 있습니다. 이것은 &quot;<code>not a</code>&quot;로 바로 읽을 수 있으며 다음의 예제에서 볼 수 있습니다.</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> allowedEntry = <span class="hljs-literal">false</span>
<span class="hljs-keyword">if</span> !allowedEnrty {
    <span class="hljs-keyword">println</span>(<span class="hljs-string">"ACCESS DENIED"</span>)
}
// prints <span class="hljs-string">"ACCESS DENIED"</span>
</code></pre>
<p><code>if !allowedEntry</code> 는 &quot;if not allowed entry&quot; 로 읽을 수 있습니다.
즉 <code>allowedEntry</code>이 <code>false</code>인 경우 라인 이후의 <code>not allowed entry</code> 가 <code>true</code>인 경우에 해당할 경우로 실행됩니다.
이 예제에서와 같이 불리언 상수와 변수 이름의 주의 깊은 선택은 이중 부정 또는 혼란한 논리구문을 피하면서 읽기 쉽고 간결한 코드를 유지하는데 도움이 될 수 있습니다.</p>
<h2><a class="anchor" aria-hidden="true" id="논리-and-연산자"></a><a href="#논리-and-연산자" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>논리 AND 연산자</h2>
<p>논리 AND 연산자(<code>a &amp;&amp; b</code>)의 전체 표현식은 두 값이 모두 <code>true</code>이어야 <code>true</code>가 됩니다.</p>
<p>반대로 두 값이 <code>false</code> 이면 전체 표현식 또한 <code>false</code> 입니다. 사실 첫번째 값이 <code>false</code> 인 경우 두번째 값이 평가되지 않습니다. 그것을 가능할수 없기 때문에 전체표현식이 <code>true</code>와 같게 됩니다. 이는 <em>short-circuit evaluation</em> 로 불립니다.</p>
<p>이 예제에서는 두 개의 <code>Bool</code>값을 고려하여 만약 두 값이 <code>true</code> 에만 접근할 수 있습니다.</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> enteredDoorCode = <span class="hljs-literal">true</span>
<span class="hljs-keyword">let</span> passedRetinaScan = <span class="hljs-literal">false</span>
<span class="hljs-keyword">if</span> enteredDoorCode &amp;&amp; passedRetinaScan {
    <span class="hljs-keyword">println</span>(<span class="hljs-string">"Welcome!"</span>)
} <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">println</span>(<span class="hljs-string">"ACCESS DENIED"</span>)
}
// prints <span class="hljs-string">"ACCESS DENIED"</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="논리-or-연산자"></a><a href="#논리-or-연산자" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>논리 OR 연산자</h2>
<p>논리 OR 연산자(<code>a || b</code>)는 인접한 파이프 문자로 만든 중위연산자 입니다. 전체표현식이 <code>true</code>가 될 때 까지 두 개의 값 중 하나만이 참이어야 하는 논리식을 만드는데 사용합니다.</p>
<p>위의 논리 AND 연산자처럼 논리 OR 연산자는 식을 고려할떄 short-circuit evaluation을 사용합니다. 논리 OR식의 좌측에 <code>true</code>가 해당하는 경우는 전체 표현식의 결과를 변경 할수 있기 때문에 우측은 계산되지 않습니다.</p>
<p>아래의 예제에서 첫 번째 <code>Bool</code> 값(<code>hasDoorKey</code>)은 <code>false</code>이지만 두 번째 값(<code>knowsOverridePassword</code>)는 <code>true</code>이다. 하나의 값 이<code>true</code>이기 떄문 전체표현식은 <code>true</code>로 평가하고 접근이 허용됩니다.</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> hasDoorKey = <span class="hljs-literal">false</span>
<span class="hljs-keyword">let</span> knowOverridePassword = <span class="hljs-literal">true</span>
<span class="hljs-keyword">if</span> hasDoorKey || knowOverridePassword {
    <span class="hljs-keyword">println</span>(<span class="hljs-string">"Welcome!"</span>)
} <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">println</span>(<span class="hljs-string">"ACCESS DENIED"</span>)
}
// prints <span class="hljs-string">"Welcome!"</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="복합-논리-연산자"></a><a href="#복합-논리-연산자" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>복합 논리 연산자</h2>
<p>당신은 여러 논리 연산자를 결합하여 복합 논리 연산자를 만들 수 있습니다.</p>
<pre><code class="hljs"><span class="hljs-built_in">if</span> enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowOverridePassword {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"Welcome!"</span>)
} <span class="hljs-built_in">else</span> {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"ACCESS DENIED"</span>)
}
<span class="hljs-comment">// prints "Welcome!"</span>
</code></pre>
<p>이 예제는 <code>&amp;&amp;</code> 및 <code>||</code> 연산자를 여러개 사용하여 긴 복합 표현식을 만들었습니다. 그러나 <code>&amp;&amp;</code> 와 <code>||</code> 연산자는 여전히 두 개의 값에 대해 작동하므로 이는 실제로 서로 세개가 연결된 작은 표현입니다.</p>
<p>만약 우리가 문의 코드를 입력하고 망막 검사를 통과한경우; 우리가 유효한 도어 키가 있는 경우이거나  긴급 재정의 암호를 알고있는 다음에 접근할 수 있습니다.</p>
<p><code>enteredDoorCode</code> 와 <code>passedRetinaScan</code> 그리고 <code>hasDoorKey</code> 의 값에 기초하여 처음 두 개의 작은 표현식은 <code>false</code> 입니다. 그러나 긴급 재정의 암호가 <code>true</code>로 알려져있습니다 ,그래서 전체 복합 표현식은 여전히 <code>true</code>로 평가됩니다.</p>
<h2><a class="anchor" aria-hidden="true" id="괄호-명시"></a><a href="#괄호-명시" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>괄호 명시</h2>
<p>괄호가 엄격히 필요하지 않은경우, 읽기 복잡한 표현의 의도록 쉽게 만들수 있는 경우에 괄호가 포함되는것이 유용한 경우가 종종 있다.</p>
<p>위의 door access 예제 코드에서 그것의 의도를 명시적으로 확인하기 위해 복합 표현식의 첫번째 부분을 괄호를 추가하는데에 유용합니다.</p>
<pre><code class="hljs"><span class="hljs-built_in">if</span> (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowOverridePassword {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"Welcome!"</span>)
} <span class="hljs-built_in">else</span> {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"ACCESS DENIED"</span>)
}
<span class="hljs-comment">// prints "Welcome!"</span>
</code></pre>
<p>괄호는 처음 두 값을 전체 논리에서 별도의 가능한 상태의 일부로 분명히 간주되게 만듭니다. 복합식의 출력이 변하지는 않지만 전체적인 목적이 독자에게 명확해집니다. 가독성은 항상 간결함을 선호합니다; 괄호의 사용은 당신의 의도를 확실히 파악하는데 도움이 됩니다.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/Swift-Korean/docs/chapter3.html">← 기초 다지기 (The Basics)</a><a class="docs-next button" href="/Swift-Korean/docs/chapter5.html">문자열과 문자 (Strings and Characters) →</a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#용어-teminology">용어 (Teminology)</a></li><li><a href="#할당-연산자">할당 연산자</a></li><li><a href="#산술-연산자">산술 연산자</a></li><li><a href="#나머지-연산자">나머지 연산자</a></li><li><a href="#부동-소수점-나머지-연산">부동 소수점 나머지 연산</a></li><li><a href="#증가연산자와-감소-연산자">증가연산자와 감소 연산자</a></li><li><a href="#단항-마이너스-연산자">단항 마이너스 연산자</a></li><li><a href="#단항-플러스-연산자">단항 플러스 연산자</a></li><li><a href="#복합-할당-연산자">복합 할당 연산자</a></li><li><a href="#비교-연산자">비교 연산자</a></li><li><a href="#삼항-조건-연산자">삼항 조건 연산자</a></li><li><a href="#범위-연산자">범위 연산자</a><ul class="toc-headings"><li><a href="#폐쇄-범위-연산자">폐쇄 범위 연산자</a></li><li><a href="#반-폐쇄-범위-연산자">반 폐쇄 범위 연산자</a></li></ul></li><li><a href="#논리-연산자">논리 연산자</a></li><li><a href="#논리-not-연산자">논리 NOT 연산자</a></li><li><a href="#논리-and-연산자">논리 AND 연산자</a></li><li><a href="#논리-or-연산자">논리 OR 연산자</a></li><li><a href="#복합-논리-연산자">복합 논리 연산자</a></li><li><a href="#괄호-명시">괄호 명시</a></li></ul></nav></div><footer class="nav-footer" id="footer"><a href="https://code.facebook.com/projects/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/Swift-Korean/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2018 Your Name or Your Company Name</section></footer></div></body></html>