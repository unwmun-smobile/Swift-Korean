<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>옵셔널 체인 (Optional Chaining) · Swift 가이드</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&gt; Translator : 허혁 (hyukhur@gmail.com)"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="옵셔널 체인 (Optional Chaining) · Swift 가이드"/><meta property="og:type" content="website"/><meta property="og:url" content="https://unwmun-smobile.github.io/Swift-Korean/index.html"/><meta property="og:description" content="&gt; Translator : 허혁 (hyukhur@gmail.com)"/><meta property="og:image" content="https://unwmun-smobile.github.io/Swift-Korean/img/docusaurus.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://unwmun-smobile.github.io/Swift-Korean/img/docusaurus.png"/><link rel="shortcut icon" href="/Swift-Korean/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/Swift-Korean/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/Swift-Korean/"><img class="logo" src="/Swift-Korean/img/docusaurus.svg" alt="Swift 가이드"/><h2 class="headerTitleWithLogo">Swift 가이드</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/Swift-Korean/docs/chapter1.html" target="_self">Docs</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>LANGUAGE GUIDE</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">WELCOME TO SWIFT</h3><ul><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter1.html">Swift에 대해서 (About Swift)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter2.html">Swift 둘러보기 (Swift Tour)</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">LANGUAGE GUIDE</h3><ul><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter3.html">기초 다지기 (The Basics)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter4.html">기본 연산자 (Basic Operators)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter5.html">문자열과 문자 (Strings and Characters)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter6.html">컬렉션 타입 (Collection Types)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter7.html">흐름 제어  (Control Flow)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter8.html">함수 (Functions)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter9.html">클로저 (Closures)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter10.html">열거형 (Enumerations)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter11.html">클래스와 구조체 (Classes and Structures)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter12.html">속성 (Properties)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter13.html">메서드 (Methods)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter14.html">서브스크립트 (Subscripts)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter15.html">상속 (Inheritance)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter16.html">초기화 (Intialization)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter17.html">해제 (Deinitialization)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter18.html">자동 참조 계수 (Automatic Reference Counting)</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/Swift-Korean/docs/chapter19.html">옵셔널 체인 (Optional Chaining)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter20.html">타입 변환 (Type Casting)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter21.html">중첩 타입 (Nested Types )</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter22.html">확장 (Extensions)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter23.html">프로토콜</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter24.html">제네릭스 (Generics)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter25.html">고급 연산자 (Advanced Operators)</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">LANGUAGE REFERENCE</h3><ul><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter26.html">언어 레퍼런스에 대하여 (About the Language Reference)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter27.html">언어 구조 (Lexcial Structure)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter28.html">타입 (Types)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter29.html">익스프레션 (Expressions)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter30.html">스테이트먼트 (Statements)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter31.html">선언 (Declarations)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter32.html">속성 (Attributes)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter33.html">패턴 (Patterns)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter34.html">제너릭 매개변수와 인자 (Generic Parameters and Arguments)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter35.html">문법 요약(Summary of the Grammar)</a></li></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">옵셔널 체인 (Optional Chaining)</h1></header><article><div><span><blockquote>
<p>Translator : 허혁 (<a href="mailto:hyukhur@gmail.com">hyukhur@gmail.com</a>)</p>
</blockquote>
<p>옵셔널 체인(Optional chaining)란 <code>nil</code>이 될 수도 있는 옵션(options)을 가진 프로퍼티(property), 메소드(method), 서브 스크립트 (subscript)에 질의하고 호출하는 프로세스를 말한다.  만약 어떤 옵션이 값을 가진다면 프로퍼티, 메소드, 서브스크립트 호출은 성공하고 옵션이 <code>nil</code>이면, 프로퍼티, 메소드, 서브스크립트 호출은 <code>nil</code>을 반환하게 된다.
여러개의 질의도 함께 엮일 수 있으며, 만약 체인(chaining) 중간의 어떤 링크가 <code>nil</code>이라면 조용하게 전체 체인은 실패한다.</p>
<blockquote>
<p>NOTE
스위프트(Swift)의 옵셔널 체인이 오브젝티브씨(Objective-C)에 있는 <code>nil</code>에 메시지 보내기와 유사하다. 그러나, 모든 타입(any type)에서 동작하고, 성공, 실패 여부를 확인할 수 있다는 점에서 차이가 있다.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="강제-랩핑-해제forced-unwrapping-대안으로써-옵셔널-체인"></a><a href="#강제-랩핑-해제forced-unwrapping-대안으로써-옵셔널-체인" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>강제 랩핑 해제(Forced Unwrapping) 대안으로써 옵셔널 체인</h2>
<p>호출하고자 하는 프로퍼티, 메소드, 서브스크립트의 옵셔널 값(optional value)이 <code>nil</code> 아닐 때 옵션값 뒤에 물음표(<code>?</code>)를 두어 옵셔널 체인을 명시 할 수 있다. 이것은 옵션널 값 뒤에 느낌표(<code>!</code>)를 두어 그 값을 강제로 랩핑 해제하는 것과 유사하다. 가장 주요한 차이점은 옵셔널 체인은 옵션이 <code>nil</code>일 때 자연스럽게 실패한다는 것이고, 강제 랩핑 해제는 옵션이 <code>nil</code>인 경우 런타임 에러가 발생한다.
옵셔널 체인이 <code>nil</code> 값에도 호출할 수 있다는 사실을 반영하기 위해 옵셔널 체인 호출 결과는 항상 옵션널 값이다. 비록 질의한 프로퍼티, 메소드, 서브스크립트가 항상 옵션널 값이 아닌 결과를 도출해도 그렇다. 이 옵션널 반환 값을 사용해서 옵셔널 체인 호출이 성공했는지 ( 반환된 옵션이 값을 가지는 ) 체인 중간의 <code>nil</code> 값 ( 옵션 반환값이 <code>nil</code> ) 때문에 실패했는지를  확인할 수 있다.
구체적으로, 옵셔널 체인 호출 결과는 옵션으로 감싸여져 있음에도 기대한 반환값과 동일한 타입이다. 일반적으로 <code>Int</code>를 반환하는 프로퍼티는 옵셔널 체인에 따라 접근이 가능할때는 <code>Int?</code>를 반환할 것이다.
다은 몇몇 코드 조각은 옵셔널 체인이 어떻게 강제 랩핑 해제와 다르고 성공 여부 확인을 가능케 하는지 보여준다.
먼저 <code>Person</code>과 <code>Residence</code>라는 클래스를 정의하자.</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
    <span class="hljs-keyword">var</span> residence: Residence?
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Residence</span> </span>{
    <span class="hljs-keyword">var</span> numberOfRooms = <span class="hljs-number">1</span>
}
</code></pre>
<p><code>Residence</code>인스턴스(Instance)는 기본값이 <code>1</code>인 <code>numberOfRooms</code>이라는 단 하나의 <code>Int</code> 프로퍼티를 가진다. <code>Person</code>인스턴스는 <code>Residence?</code>타입으로 <code>residence</code>이라는 옵셔널 프로퍼티를 가진다.
만약 <code>Person</code>이라는 인스턴스를 새로 만들면, 옵셔널 효과에 따라 기본적으로 <code>nil</code>로 설정된다. 아래 코드에서는 <code>john</code>는 <code>nil</code>로 된 <code>residence</code>프로퍼티를 가질 것이다.</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> <span class="hljs-attr">jone</span> = Person()
</code></pre>
<p>만약 <code>Person</code>의 <code>residence</code>의 <code>numberOfRooms</code>프로퍼티를 그 값을 강제로 랩핑 해제를 하려고 느낌표를 붙여서 접근한다면 런타임 에러(Runtime Error)를 유발시킬 것이다. 왜냐하면 해제할 <code>residence</code>값 자체가 없기 때문이다.</p>
<pre><code class="hljs">let roomCount = john<span class="hljs-selector-class">.residence</span><span class="hljs-selector-class">.numberOfRooms</span>
</code></pre>
<p>위 코드는 <code>john.residence</code>가 <code>nil</code>이 아닌 값을 성공하며 방 갯수에 적절한 숫자를 담고 있는 Int 값에 <code>roomCount</code>를 설정할 것이다. 그러나 이 코드는 위에 보여지는 것처럼 <code>residence</code>가 <code>nil</code>이라면 항상 런타임 에러를 유발 시킨다.
옵셔널 체인은 <code>numberOfRooms</code>값에 접근하는데 대안법을 제공한다. 옵셔널 체인을 사용하기 위해 느낌표 자리에 물음표를 사용하면 된다.</p>
<pre><code class="hljs"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> roomCount = john.residence?.numberOfRooms {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"John's residence has <span class="hljs-subst">\(roomCount)</span> room(s)."</span>)
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"Unable to retrieve the number of rooms."</span>)
}
<span class="hljs-comment">// prints "Unable to retrieve the number of rooms."</span>
</code></pre>
<p>이것은 스위프트(swift)가 옵셔널 <code>residence</code>프로퍼티를 &quot;묶고&quot; 만약 <code>residence</code>가 있으면 <code>numberOfRooms</code>값을 가져온다는 것을 말해준다.</p>
<p><code>numberOfRoom</code>에 대한 접근이가 잠제적으로 실패할 수 있기 때문에 옵셔널 체인은 <code>Int?</code>이나 &quot;옵션널 <code>Int</code>&quot;형 값을 반환하려고 한다. 위 예제처럼 <code>residence</code>가 <code>nil</code>인 경우는 <code>numberOfRooms</code>에 대한 접근이 불가능하다는 사실을 반영하기 위해서 이 옵셔널<code>Int</code> 역시 <code>nil</code>이 될 것이다.
<code>numberOfRooms</code>가 비옵셔널 <code>Int</code>임에도 불구하고 참인 것을 명심해라. 옵셔널 체인을 통해 질의한다는 것은 <code>numberOfRooms</code>가 <code>Int</code> 대신 <code>Int?</code>를 항상 반환할 것이라는 것을 의미한다.
<code>john.residence</code>에 <code>Residence</code> 인스턴스를 할당할 수 있는데 그러면 더이상 <code>nil</code>값은 존재하지 않게 된다.</p>
<pre><code class="hljs">john<span class="hljs-selector-class">.residence</span> = Residence()
</code></pre>
<p><code>john.residence</code>는 실체 <code>Residence</code>인스턴스를 이제 가지게 되었다. 만약 예전과 동일한 옵셔널 체인을 사용해 접근하려고 하면, <code>1</code>이라는 <code>numberOfRooms</code>기본값을 가지는 <code>Int?</code>가 반환될 것이다.</p>
<pre><code class="hljs"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> roomCount = john.residence?.numberOfRooms {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"John's residence has <span class="hljs-subst">\(roomCount)</span> room(s)."</span>)
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"Unable to retrieve the number of rooms."</span>)
}
<span class="hljs-comment">// prints "John's residence has 1 room(s)."</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="옵셔널-체인을-위한-모델model-클래스class-선언"></a><a href="#옵셔널-체인을-위한-모델model-클래스class-선언" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>옵셔널 체인을 위한 모델(Model) 클래스(Class) 선언</h2>
<p>프로퍼티, 메소드, 서브스크립트를 호출하는 것 같은 한단계 더 깊은 옵셔널 체인을 사용할 수 있다. 이는 상호관계있는 타입간의 복잡한 모델에서 서브 프로퍼티(subproperty)를 파고 들 수 있게 해주고 그 서브 프로터티에 프로퍼티와 메소드, 서브스크립트에 접근할 수 있는지 아닌지를 확인할 수 있게 해준다.
다음 코드 조각은 다단계 옵셔널 체인 예를 포함한 몇가지 순차적인 예제에서 사용될 4개의 모델 클래스를 정의한다. 이 클래스들은 위에 나온 <code>Person</code>과 <code>Residence</code> 모델에 <code>Room</code>과 <code>Address</code> 클래스를 추가하고 연관 프로퍼티와 메소드, 서브스크립트를 확장한다.
<code>Person</code> 클래스는 이전과 동일한 방법으로 정의한다.</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
    <span class="hljs-keyword">var</span> residence: Residence?
}
</code></pre>
<p><code>Residence</code> 클래스는 이전보다 조금 복잡해졌다. 이번에는 <code>Residence</code> 클래스에 <code>Room[]</code> 타입의 빈 배열로 초기화된 <code>rooms</code>라는 변수 프로퍼티를 선언한다.</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Residence</span> </span>{
    <span class="hljs-keyword">var</span> rooms = <span class="hljs-type">Room</span>[]()
    <span class="hljs-keyword">var</span> numberOfRooms: <span class="hljs-type">Int</span> {
    <span class="hljs-keyword">return</span> rooms.<span class="hljs-built_in">count</span>
    }
    <span class="hljs-keyword">subscript</span>(i: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Room</span> {
        <span class="hljs-keyword">return</span> rooms[i]
    }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printNumberOfRooms</span><span class="hljs-params">()</span></span> {
        <span class="hljs-built_in">println</span>(<span class="hljs-string">"The number of rooms is <span class="hljs-subst">\(numberOfRooms)</span>"</span>)
    }
    <span class="hljs-keyword">var</span> address: <span class="hljs-type">Address</span>?
}
</code></pre>
<p>이번 버전 <code>Residence</code>는 <code>Room</code>인스턴스 배열을 저장하기 때문에, 그 <code>numberOfRooms</code>프로퍼티는 저장된 프로퍼티가 아닌 계산된 프로퍼티로 구현했다. 계산된 <code>numberOfRooms</code>프로퍼티는 단순히 <code>rooms</code>배열에서 <code>count</code>프로퍼티의 값을 반환한다.
그 <code>rooms</code>배열에 접근하기 위한 바로가기로 이번 버전 <code>Residence</code>는 읽기만 가능한 서브 스크립트를 제공하는데 서브스크립트에게 전달받는 인덱스(index)가 적합할 것이라는 가정으로 시작해보겠다. 만약 인덱스가 적합하다면, 서브스크립트는 <code>rooms</code> 배열의 요청받은 인덱스의 방 정보를 반환할 것이다.
또한 이번 버전 <code>Residence</code>는 <code>printNumberOfRooms</code>라는 이름의 메소드를 제공하는데 단순히 <code>Residence</code>에 방 갯수를 출력한다.
마지막으로 <code>Residence</code>에 <code>Address?</code>이란 타입으로 <code>address</code>라는 옵셔널 프로퍼티를 선언한다. 이를 위한 <code>Address</code>클래스 타입은 밑에 정의하겠다.
<code>rooms</code>배열에 사용하는 <code>Room</code>클래스는 <code>name</code>이라는 프로퍼티 하나를 가지는 간단한 클래스인데 이는 적절한 방이름을 설정하기 위한 초기화 역할(initializer)을 한다.</p>
<pre><code class="hljs"><span class="hljs-built_in">class</span> Room {
    let <span class="hljs-built_in">name</span>: String
    init(<span class="hljs-built_in">name</span>: String) { self.<span class="hljs-built_in">name</span> = <span class="hljs-built_in">name</span> }
}
</code></pre>
<p>이 모델의 마지막 클래스는 <code>Address</code>이다. 이 클래스는 <code>String?</code>타입의 옵셔널 프로퍼티를 3개 가지고 있다. 그 중 2개는 <code>buildingName</code>과 <code>buildingNumber</code> 인데 주소를 구성하는 특정 빌딩에 대한 구분을 짓기 위한 대체 수단이다. 3번째 프로퍼티인 <code>street</code>는 그 주소의 도로이름에 사용한다.</p>
<pre><code class="hljs"><span class="hljs-symbol">class</span> <span class="hljs-keyword">Address </span>{
    var <span class="hljs-keyword">buildingName: </span><span class="hljs-keyword">String?
</span>    var <span class="hljs-keyword">buildingNumber: </span><span class="hljs-keyword">String?
</span>    var <span class="hljs-keyword">street: </span><span class="hljs-keyword">String?
</span>    func <span class="hljs-keyword">buildingIdentifier() </span>-&gt; <span class="hljs-keyword">String? </span>{
        <span class="hljs-meta">if</span> <span class="hljs-keyword">buildingName </span>{
            return <span class="hljs-keyword">buildingName
</span>        } <span class="hljs-meta">else</span> <span class="hljs-meta">if</span> <span class="hljs-keyword">buildingNumber </span>{
            return <span class="hljs-keyword">buildingNumber
</span>        } <span class="hljs-meta">else</span> {
            return nil
        }
    }
}
</code></pre>
<p>또한 <code>Address</code>클래스는 <code>String?</code>반환값을 가지는 <code>buildingIdentifer</code>이란 이름의 메소드를 제공한다. 이 메소드는 <code>buildingName</code>과 <code>buildingNumber</code>프로퍼티를 확인해서 만약 <code>buildingName</code>이 값을 가진다면 그 값을 혹은 <code>buildingNumber</code>이 값을 가진다면 그 값을, 둘다 값이 없다면 <code>nil</code>을 반환한다.</p>
<h2><a class="anchor" aria-hidden="true" id="옵셔널-체인를-통한-프로퍼티-호출"></a><a href="#옵셔널-체인를-통한-프로퍼티-호출" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>옵셔널 체인를 통한 프로퍼티 호출</h2>
<p>강제 랩핑 해제(Forced Unwrapping) 대안으로써 옵셔널 체인에서 봤던 것처럼 옵셔널 체인을 온션값에 대한 프로퍼티 접근에 접근할 수 있는지 만약 프로퍼티 접근이 가능한지 확인하기 위해 사용할 수 있다. 그러나선택 묶임를 통해 프로퍼티의 값을 설정하는 것은 할 수 없다.
위에 정의한 새로운 <code>Person</code> 인스턴스를 사용해 클래스를 만들어 이전처럼 <code>numberOfRooms</code> 프로퍼티에 접근하기를 시도해본다.</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> john = <span class="hljs-type">Person</span>()
<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> roomCount = john.residence?.numberOfRooms {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"John's residence has <span class="hljs-subst">\(roomCount)</span> room(s)."</span>)
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"Unable to retrieve the number of rooms."</span>)
}
<span class="hljs-comment">// prints "Unable to retrieve the number of rooms."</span>
</code></pre>
<p><code>john.residence</code>가 <code>nil</code>이기 때문에 이 옵셔널 체인을 예전과 동일한 방식으로 호출했지만 에러 없이 실패한다.</p>
<h2><a class="anchor" aria-hidden="true" id="옵셔널-체인을-통한-메소드-호출"></a><a href="#옵셔널-체인을-통한-메소드-호출" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>옵셔널 체인을 통한 메소드 호출</h2>
<p>옵셔널 체인을 사용해서 옵션값을 호출하고 메소드 호출이 성공했는지 여부를 확인해볼 수 있다. 설렁 메소드가 반환값을 정의하지 않더라고 할 수 있다.
<code>Residence</code> 클래스에 있는 <code>printNumberOfRooms</code>메소드는 <code>numberOfRooms</code>의 현재 값을 출력한다. 그 메소드는 다음과 같을 것이다.</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printNumberOfRooms</span><span class="hljs-params">()</span></span> {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"The number of rooms is <span class="hljs-subst">\(numberOfRooms)</span>"</span>)
}
</code></pre>
<p>이 메소드는 반환값을 명시하지 않았다. 그러나 반환형이 없는 함수와 메소드는 <code>Functions Without Return Values</code>에 나와 있는 것처럼 암시적으로 <code>Void</code>타입을 반환하게 된다.
만약 옵셔널 체인에 있는 옵션값에 이 메소드를 호출한다면, 메소드 반환형은 <code>Void</code>가 아니라 <code>Void?</code>이 될 것이다. 옵셔널 체인을 통해 호출될 때 옵셔널 타입은 항상 반환 값을 가지기 때문이다. 이는 메소드가 반환값이 정의되어 있지 않더라도 <code>printNumberOfRooms</code>메소드를 호출이 가능한지를 <code>if</code>문을 써서 확인할 수 있게 한다. <code>printNumberOfRooms</code>에서 암시적 반환값은 만약 메소드가 옵셔널 체인를 통해 성공적으로 호출되었다면 <code>Void</code>와 동일할 것이고 그렇지 않다면 <code>nil</code>과 동일할 것이다.</p>
<pre><code class="hljs"><span class="hljs-built_in">if</span> john.residence?.printNumberOfRooms() {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"It was possible to print the number of rooms."</span>)
} <span class="hljs-built_in">else</span> {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"It was not possible to print the number of rooms."</span>)
}
<span class="hljs-comment">// prints "It was not possible to print the number of rooms."</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="옵셔널-체인을-통한-서브스크립트-호출"></a><a href="#옵셔널-체인을-통한-서브스크립트-호출" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>옵셔널 체인을 통한 서브스크립트 호출</h2>
<p>옵셔널값에 대한 서브스크립트에서 값을 가져와서 서브스크립트 호출이 성공했는지 확인하기 위해 옵셔널 체인을 사용할 수 있다. 그러나 을 통해 서브스크립트로 값을 설정하는 것은 할 수 없다.</p>
<blockquote>
<p>NOTE
옵셔널 체인를 통해 옵션값에 대한 서브스크립트를 접근할 때 서브스크립트 꺽은 괄호(bracket) 앞에 물음표를 놓아야 한다. 뒤가 아니다. 옵셔널 체인 물음표는 항상 옵셔널 표현식의 뒤에 바로 따라나와야 한다.</p>
</blockquote>
<p>아래 예는 <code>Residence</code>클래스에 정의되어 있는 서브스크립트를 사용하는 <code>john.residence</code> 프로퍼티의 <code>rooms</code>배열에 있는 첫번째 방이름을 집어오려고 하는 것이다. <code>john.residence</code>가 현재 <code>nil</code>이기 때문에 서브스크립트는 실패한다.</p>
<pre><code class="hljs"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> firstRoomName = john.residence?[<span class="hljs-number">0</span>].name {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"The first room name is <span class="hljs-subst">\(firstRoomName)</span>."</span>)
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"Unable to retrieve the first room name."</span>)
}
<span class="hljs-comment">// prints "Unable to retrieve the first room name."</span>
</code></pre>
<p>이 서브스크립트 호출 속에 있는 옵셔널 체인 물음표는 <code>john.residence</code>바로 뒤, 서브스크립트 꺽은 괄호 전에 존재해야한다. 왜냐하면, <code>john.residence</code>가 옵셔널 체인을 꾀할 옵션값이기 때문이다.
만약, <code>john.residence</code>에 <code>rooms</code>배열에 한개 이상의 <code>Room</code>인스턴스도 같이 실제 <code>Residence</code>를 만들어서 할당한다면 옵셔널 체인을 통해 <code>rooms</code>배열안의 실제 아이템에 접근하기 위해서 <code>Residence</code>서브스크립트를 사용할 수 있다.</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> <span class="hljs-attr">johnsHouse</span> = Residence()
johnsHouse.rooms += Room(name: <span class="hljs-string">"Living Room"</span>)
johnsHouse.rooms += Room(name: <span class="hljs-string">"Kitchen"</span>)
john.<span class="hljs-attr">residence</span> = johnsHouse
<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-attr">firstRoomName</span> = john.residence?[<span class="hljs-number">0</span>].name {
    println(<span class="hljs-string">"The first room name is \(firstRoomName)."</span>)
} <span class="hljs-keyword">else</span> {
    println(<span class="hljs-string">"Unable to retrieve the first room name."</span>)
}
// prints <span class="hljs-string">"The first room name is Living Room."</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="다단계-묶임-연결하기"></a><a href="#다단계-묶임-연결하기" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>다단계 묶임 연결하기</h2>
<p>프로퍼티와 메소드, 서브스크립트를 사용해 모델 깊이 파고들기 위해서 옵셔널 체인을 여러 단계로 함께 엮을 수 있다. 그러나 다단계 옵셔널 체인으로 반환값에 더 많은 옵셔널 단계를 넣을 수는 없다.
다른 방식으로:</p>
<ul>
<li>만약 집어오려고 하는 타입이 옵셔널이지 않으면, 옵셔널 체인으로 인해 옵셔널로 변경될 것이다.</li>
<li>만약 집어오려고 하는 타입이 이미 옵셔널이라면, 옵셔널 체인으로 인해 더 옵셔널로 변경되지는 않을 것이다.</li>
</ul>
<p>그러므로:</p>
<ul>
<li><code>Int</code>타입을 옵셔널 체인을 통해 집어오려고 하면, 항상 <code>Int?</code>가 반환될 것이다. 얼마나 많은 단계의 체인이 사용되었는지는 중요하지 않다.</li>
<li>유사하게, <code>Int?</code>값을 집어오려고 하면, 항상 <code>Int?</code>가 반환될 것이다.  얼마나 많은 단계의 체인이 사용되었는지는 중요하지 않다.</li>
</ul>
<p>아래 예는 <code>john</code>의 <code>residence</code>프로퍼티의 <code>address</code>프로퍼티의 <code>street</code>프로퍼티에 접근하려는 것을 보여준다. 여기에 사용되는 2개의 옵셔널 체인 단계가 있는데 <code>residence</code>와 <code>address</code>로 둘은 엮여 있고 둘다 옵셔널타입이다.</p>
<pre><code class="hljs"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> johnsStreet = john.residence?.address?.street {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"John's street name is <span class="hljs-subst">\(johnsStreet)</span>."</span>)
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"Unable to retrieve the address."</span>)
}
<span class="hljs-comment">// prints "Unable to retrieve the address."</span>
</code></pre>
<p><code>john.residence</code>의 값은 현재 적합한 <code>Residence</code>인스턴스를 포함하고 있다. 그러나 <code>john.residence.address</code>의 값은 현재 <code>nil</code>이다. 이때문에, <code>john.residence?.address?.street</code>호출은 실패한다.
위 예제를 잘 생각해보자. <code>street</code>프로퍼티 값을 집어오고자 했다. 이 프로퍼티는 <code>String?</code>이다. 그러므로  <code>john.residence?.address?.street</code>의 반환값 역시 두단계 옵셔널 체인으로 프로퍼티가 옵셔널타입에 추가로 더해 적용되었음에도 불구하고 <code>String?</code>이다.
만약 <code>john.residence.address</code>의 값으로써 실제 <code>Address</code>인스턴스를 설정하고 그 <code>Adress</code>의 <code>street</code>프로퍼티에 실제 값을 설정한다면, 다단계 옵셔널 체인을 통해 그 프로퍼티 값을 접근할 수 있을 것이다.</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> <span class="hljs-attr">johnsAddress</span> = Address()
johnsAddress.<span class="hljs-attr">buildingName</span> = <span class="hljs-string">"The Larches"</span>
johnsAddress.<span class="hljs-attr">street</span> = <span class="hljs-string">"Laurel Street"</span>
john.residence!.<span class="hljs-attr">address</span> = johnsAddress
<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-attr">johnsStreet</span> = john.residence?.address?.street {
    println(<span class="hljs-string">"John's street name is \(johnsStreet)."</span>)
} <span class="hljs-keyword">else</span> {
    println(<span class="hljs-string">"Unable to retrieve the address."</span>)
}
// prints <span class="hljs-string">"John's street name is Laurel Street."</span>
</code></pre>
<p><code>john.residence.address</code>의 <code>address</code>인스턴스에 할당하기 위해서 느낌표를 사용한 것을 잘보자. <code>john.residence</code>프로퍼티는 옵셔널타입을 가지기에 <code>Residence</code>의 <code>address</code>프로퍼티에 접근하기 전에 느낌표를 사용해서 그 실제 값을 까볼 필요가 있다.</p>
<h2><a class="anchor" aria-hidden="true" id="옵셔널-반환값을-사용해서-메소드-체인"></a><a href="#옵셔널-반환값을-사용해서-메소드-체인" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>옵셔널 반환값을 사용해서 메소드 체인</h2>
<p>이전 예제는 옵셔널 체인을 사용해서 옵셔널타입의 프로퍼티의 값을 어떻게 집어오는지 보여주었다. 또한 옵셔널 체인을 사용해서 옵셔널타입 값을 반환하는 메소드를 호출하고 필요하다면 그 메소드의 반환값을 연결할 수 있었다.
아래 예제는 옵셔널 체인을 통해 <code>Address</code> 클래스의 <code>buildingIndentifer</code> 메소드를 호출한다. 이 메소드는 <code>String?</code> 타입의 값을 반환한다. 이전에 설명한대로, 옵셔널 체인에 따라 호출된 메소드의 최종 반환값 또한 <code>String?</code>이 된다.</p>
<pre><code class="hljs"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> buildingIdentifier = john.residence?.address?.buildingIdentifier() {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"John's building identifier is <span class="hljs-subst">\(buildingIdentifier)</span>."</span>)
}
<span class="hljs-comment">// prints "John's building identifier is The Larches."</span>
</code></pre>
<p>만약 이 메소드 반환값 이상의 옵셔널 체인을 실행하기 원한다면, 메소드 둥근 괄호(parentheses) 다 음옵셔널 체인음 물음표를 두면 된다.</p>
<pre><code class="hljs"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> upper = john.residence?.address?.buildingIdentifier()?.uppercaseString {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"John's uppercase building identifier is <span class="hljs-subst">\(upper)</span>."</span>)
}
<span class="hljs-comment">// prints "John's uppercase building identifier is THE LARCHES."  </span>
</code></pre>
<blockquote>
<p>NOTE
위 예제에서 둥근 괄호 다음에 옵셔널 체인 물음표를 놓았는데, 묶고자 하는 옵션값이 <code>buildingIndentifer</code> 자체가 아니라 <code>buildingIndentifer</code> 메소드의 반환값이기 때문이다.</p>
</blockquote>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/Swift-Korean/docs/chapter18.html">← 자동 참조 계수 (Automatic Reference Counting)</a><a class="docs-next button" href="/Swift-Korean/docs/chapter20.html">타입 변환 (Type Casting) →</a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#강제-랩핑-해제forced-unwrapping-대안으로써-옵셔널-체인">강제 랩핑 해제(Forced Unwrapping) 대안으로써 옵셔널 체인</a></li><li><a href="#옵셔널-체인을-위한-모델model-클래스class-선언">옵셔널 체인을 위한 모델(Model) 클래스(Class) 선언</a></li><li><a href="#옵셔널-체인를-통한-프로퍼티-호출">옵셔널 체인를 통한 프로퍼티 호출</a></li><li><a href="#옵셔널-체인을-통한-메소드-호출">옵셔널 체인을 통한 메소드 호출</a></li><li><a href="#옵셔널-체인을-통한-서브스크립트-호출">옵셔널 체인을 통한 서브스크립트 호출</a></li><li><a href="#다단계-묶임-연결하기">다단계 묶임 연결하기</a></li><li><a href="#옵셔널-반환값을-사용해서-메소드-체인">옵셔널 반환값을 사용해서 메소드 체인</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/Swift-Korean/" class="nav-home"><img src="/Swift-Korean/img/docusaurus.svg" alt="Swift 가이드" width="66" height="58"/></a><div><h5>Docs</h5><a href="/Swift-Korean/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/Swift-Korean/docs/en/doc2.html">Guides (or other categories)</a><a href="/Swift-Korean/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/Swift-Korean/en/users.html">User Showcase</a><a href="http://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/Swift-Korean/blog">Blog</a><a href="https://github.com/">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/Swift-Korean/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2018 Your Name or Your Company Name</section></footer></div></body></html>