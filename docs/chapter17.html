<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>해제 (Deinitialization) · Swift 가이드</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&gt; Translator : 물좀 (메일주소)"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="해제 (Deinitialization) · Swift 가이드"/><meta property="og:type" content="website"/><meta property="og:url" content="https://unwmun-smobile.github.io/Swift-Korean/index.html"/><meta property="og:description" content="&gt; Translator : 물좀 (메일주소)"/><meta property="og:image" content="https://unwmun-smobile.github.io/Swift-Korean/img/swift.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://unwmun-smobile.github.io/Swift-Korean/img/swift.png"/><link rel="shortcut icon" href="/Swift-Korean/img/swift.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/Swift-Korean/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/Swift-Korean/"><img class="logo" src="/Swift-Korean/img/swift.png" alt="Swift 가이드"/><h2 class="headerTitleWithLogo">Swift 가이드</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/Swift-Korean/docs/chapter1.html" target="_self">Docs</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>LANGUAGE GUIDE</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">WELCOME TO SWIFT</h3><ul><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter1.html">Swift에 대해서 (About Swift)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter2.html">Swift 둘러보기 (Swift Tour)</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">LANGUAGE GUIDE</h3><ul><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter3.html">기초 다지기 (The Basics)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter4.html">기본 연산자 (Basic Operators)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter5.html">문자열과 문자 (Strings and Characters)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter6.html">컬렉션 타입 (Collection Types)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter7.html">흐름 제어  (Control Flow)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter8.html">함수 (Functions)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter9.html">클로저 (Closures)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter10.html">열거형 (Enumerations)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter11.html">클래스와 구조체 (Classes and Structures)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter12.html">속성 (Properties)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter13.html">메서드 (Methods)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter14.html">서브스크립트 (Subscripts)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter15.html">상속 (Inheritance)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter16.html">초기화 (Intialization)</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/Swift-Korean/docs/chapter17.html">해제 (Deinitialization)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter18.html">자동 참조 계수 (Automatic Reference Counting)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter19.html">옵셔널 체인 (Optional Chaining)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter20.html">타입 변환 (Type Casting)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter21.html">중첩 타입 (Nested Types )</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter22.html">확장 (Extensions)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter23.html">프로토콜</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter24.html">제네릭스 (Generics)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter25.html">고급 연산자 (Advanced Operators)</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">LANGUAGE REFERENCE</h3><ul><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter26.html">언어 레퍼런스에 대하여 (About the Language Reference)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter27.html">언어 구조 (Lexcial Structure)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter28.html">타입 (Types)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter29.html">익스프레션 (Expressions)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter30.html">스테이트먼트 (Statements)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter31.html">선언 (Declarations)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter32.html">속성 (Attributes)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter33.html">패턴 (Patterns)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter34.html">제너릭 매개변수와 인자 (Generic Parameters and Arguments)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter35.html">문법 요약(Summary of the Grammar)</a></li></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">해제 (Deinitialization)</h1></header><article><div><span><blockquote>
<p>Translator : 물좀 (메일주소)</p>
</blockquote>
<p>deinitializer는 임의의 class 인스턴스가 할당해제(deallocate) 되기 직전에 호출된다. initializer를 <code>init</code> 키워드 안에 기술했던 것처럼, deinitializer는 <code>deinit</code> 키워드 안에 적어 넣는다. deinitializer는 class 타입 인스턴스에서만 사용할 수 있다.</p>
<h2><a class="anchor" aria-hidden="true" id="deinitialization-해제-의-원리"></a><a href="#deinitialization-해제-의-원리" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Deinitialization (해제)의 원리</h2>
<p><a href="">Automatic Reference Counting</a> 에서 설명된 바와 같이, Swift에서는 더 이상 사용되지 않는 인스턴스는 ARC에 의해 자동으로 할당해제 된다. 따라서 대부분의 경우 사용자가 직접 할당해제 할 필요가 없다. 하지만, 사용자의 인스턴스에서 직접 리소스를 할당하여 사용했다면, 해제할 때도 직접 해제해 주어야 한다. 가령, 사용자의 인스턴스에서 파일을 열어서 사용했다면, 해제할 때, 직접 파일을 닫아주어야 한다. class마다 오직 한 개의 deinitializer만을 사용할 수 있으며, 파라미터 없이 정의한다.</p>
<pre><code class="hljs"><span class="hljs-class">deinit </span>{
     <span class="hljs-comment">// perform the deinitialization</span>
}
</code></pre>
<p>deinitializer는 할당해제(deallocation)가 일어나기 직전에 자동으로 호출되기 때문에, 사용자가 직접 호출하는 것을 허용하지 않는다. subclass는 superclass의 deinitializer를 상속받기 때문에, subclass의 deinitializer가 호출되어 작업을 마친 후, superclass의 deinitializer가 자동으로 호출된다. superclass의 deinitializer는 subclass의 deinitializer가 정의되지 않았더라도 항상 호출된다. deinitializer가 아직 호출되지 않은 인스턴스는 해제(deallocation)가 되지 않은 상태이고, deinitializer는 자신이 속한 인스턴스의 모든 속성(가령, 닫아야할 파일의 이름과 상태)을 변경할 수 있다.</p>
<h2><a class="anchor" aria-hidden="true" id="deinitializer-사용-예"></a><a href="#deinitializer-사용-예" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Deinitializer 사용 예</h2>
<p>deinitializer를 사용하는 간단한 예를 들어보자. 간단한 게임을 만들기 위해, Bank와 Player 라는 두개의 데이터 타입을 정의하기로 하자. <code>Bank</code>는 화폐를 만드는데, 최대 10,000개의 동전을 유통할 수 있다. 게임에서는 오직 한 개의 <code>Bank</code>만 있다고 가정, <code>Bank</code>는 static으로 구현되었다.</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Bank</span> </span>{
     <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> coinsInBank = <span class="hljs-number">10000</span>
     <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">vendCoins</span><span class="hljs-params">(<span class="hljs-keyword">var</span> numberOfCoinsToVend: Int)</span></span> -&gt; <span class="hljs-type">Int</span> {
          numberOfCoinsToVend = <span class="hljs-built_in">min</span>(numberOfCoinsToVend, coinsInBank)
          coinsInBank -= numberOfCoinsToVend
          <span class="hljs-keyword">return</span> numberOfCoinsToVend
     }
     <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">receiveCoins</span><span class="hljs-params">(coins: Int)</span></span> {
     coinsInBank += coins
}
</code></pre>
<p><code>Bank</code>클래스는 <code>coinsInBank</code> 속성으로 현 상태의 동전 수를 유지한다. <code>vendCoins</code>과  <code>receiveCoins</code> 메소드는 동전을 인출하거나 예치할 때 사용한다.</p>
<p><code>vendCoins</code> 메소드는 은행에 동전이 남아 있는지 확인하고 Player에게 인출을 허용한다. Player 가 요청한 것보다 동전이 적게 남아 있으면, 남아 있는 만큼만 인출할 수 있다. (물론 은행에 동전이 전혀 없다면, ‘0’ 를 리턴한다). <code>numberOfCoinsToVend</code> 변수는 파라미터로 입력받아 변경이 가능하게 만들었다. <code>receiveCoins</code> 메소드는  단순히 Player가 예치하는 동전을 은행에 더해서 쌓도록 되어 있다.</p>
<p><code>Player</code> 클래스를 보면, <code>coinsInPurse</code> 속성에  게임 플레이어가 현재 보유한 동전을 기록한다.</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> </span>{
     <span class="hljs-keyword">var</span> coinsInPurse: <span class="hljs-type">Int</span>
     <span class="hljs-keyword">init</span>(coins: <span class="hljs-type">Int</span>) {
          coinsInPurse = <span class="hljs-type">Bank</span>.vendCoins(coins)
     }
     <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">winCoins</span><span class="hljs-params">(coins: Int)</span></span> {
          coinsInPurse += <span class="hljs-type">Bank</span>.vendCoins(coins)
     }
     <span class="hljs-keyword">deinit</span> {
          <span class="hljs-type">Bank</span>.receiveCoins(coinsInPurse)
     }
}
</code></pre>
<p><code>Player</code> 인스턴스는 은행으로부터 동전을 받으면서 초기화된다. 경우에 따라 은행에 충분한 코인이 남아 있지 않다면 요청한 만큼의 동전보다 적게 받을 수도 있다. <code>winCoins</code> 메소드는 은행에서 (coins : Int) 만큼의 동전을 받아 Player의 지갑에 더해 준다. <code>Player</code> 클래스에는 deinitializer 가 정의되어 있는데, 앞서 설명한 바 처럼 <code>Player</code> 인스턴스가 해제(deallocate)되기 직전에 호출된다. 여기서는 단순히 플레이어가 가진 모든 동전을 다시 은행으로 되돌려 보내는 작업을 한다.</p>
<pre><code class="hljs"><span class="hljs-keyword">var</span> playerOne: <span class="hljs-type">Player</span>? = <span class="hljs-type">Player</span>(coins: <span class="hljs-number">100</span>)
<span class="hljs-built_in">println</span>(<span class="hljs-string">"A new player has joined the game with <span class="hljs-subst">\(playerOne!.coinsInPurse)</span> coins"</span>)
<span class="hljs-comment">// prints "A new player has joined the game with 100 coins"</span>
<span class="hljs-built_in">println</span>(<span class="hljs-string">"There are now <span class="hljs-subst">\(Bank.coinsInBank)</span> coins left in the bank"</span>)
<span class="hljs-comment">// prints "There are now 9900 coins left in the bank"</span>
</code></pre>
<p><code>Player</code> 인스턴스를 만들때, 은행에 100 코인을 요청한다. 이 <code>Player</code> 인스턴스는 optional 변수 <code>playerOne</code>에 저장된다. 여기서 optional 변수가 사용된 이유는 게임 player들이 수시로 게임에서 나갈 수 있기 때문이다. optional을 사용함으로써 그 인스턴스가 현재 게임에 있는지 아닌지를 추적할 수 있다.</p>
<p>또한 느낌표 (<code>!</code>) 연산자를 사용, <code>coinsInPurse</code> 가 호출될때, optional으로 선언된 기본값 (100) 대신 현재 인스턴스가 가지고 있는 값 (2100)이 출력되게 할 수도 있다.</p>
<pre><code class="hljs">playerOne!.winCoins(<span class="hljs-number">2000</span>)
<span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">"PlayerOne won 2000 coins &amp; now has \(playerOne!.coinsInPurse) coins"</span>)</span></span>
_<span class="hljs-comment">// prints "PlayerOne won 2000 coins &amp; now has 2100 coins"_</span>
<span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">"The bank now only has \(Bank.coinsInBank) coins left"</span>)</span></span>
_<span class="hljs-comment">// prints "The bank now only has 7900 coins left"_</span>
</code></pre>
<p>결과를 보면, <code>playerOne</code>은 요청한 2000 코인 모두를 은행으로부터 받아서, 현재는 2100 코인을 가지고 있으며 은행에 남아 있는 코인 수는 7900이 되었다.</p>
<pre><code class="hljs">playerOne = nil
<span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">"PlayerOne has left the game"</span>)</span></span>
<span class="hljs-comment">// prints "PlayerOne has left the game"</span>
<span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">"The bank now has \(Bank.coinsInBank) coins"</span>)</span></span>
<span class="hljs-comment">// prints "The bank now has 10000 coins"</span>
</code></pre>
<p><code>playerOne</code>을 <code>nil</code>로 셋팅함으로써, <code>playerOne</code>이 게임에서 나간 상태를 표현할 수 있으며, <code>playerOne</code>이 가지고 있던 코인은 모두 은행에 환수되었음을 알 수 있다.
그 과정은  <code>playerOne</code> 변수의 참조(reference)는 더 이상 유효하지 않게 되고, denitializer가 호출되고, deallocation 과정으로 사용중이던 메모리도 환원된다.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/Swift-Korean/docs/chapter16.html">← 초기화 (Intialization)</a><a class="docs-next button" href="/Swift-Korean/docs/chapter18.html">자동 참조 계수 (Automatic Reference Counting) →</a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#deinitialization-해제-의-원리">Deinitialization (해제)의 원리</a></li><li><a href="#deinitializer-사용-예">Deinitializer 사용 예</a></li></ul></nav></div><footer class="nav-footer" id="footer"><a href="https://code.facebook.com/projects/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/Swift-Korean/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2018 Your Name or Your Company Name</section></footer></div></body></html>