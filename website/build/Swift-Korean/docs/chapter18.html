<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>자동 참조 계수 (Automatic Reference Counting) · Swift 가이드</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&gt; Translator : Quartet ( ungsik.yun@gmail.com )"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="자동 참조 계수 (Automatic Reference Counting) · Swift 가이드"/><meta property="og:type" content="website"/><meta property="og:url" content="https://unwmun-smobile.github.io/Swift-Korean/index.html"/><meta property="og:description" content="&gt; Translator : Quartet ( ungsik.yun@gmail.com )"/><meta property="og:image" content="https://unwmun-smobile.github.io/Swift-Korean/img/docusaurus.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://unwmun-smobile.github.io/Swift-Korean/img/docusaurus.png"/><link rel="shortcut icon" href="/Swift-Korean/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/Swift-Korean/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/Swift-Korean/"><img class="logo" src="/Swift-Korean/img/docusaurus.svg" alt="Swift 가이드"/><h2 class="headerTitleWithLogo">Swift 가이드</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/Swift-Korean/docs/chapter1.html" target="_self">Docs</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>LANGUAGE GUIDE</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">WELCOME TO SWIFT</h3><ul><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter1.html">Swift에 대해서 (About Swift)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter2.html">Swift 둘러보기 (Swift Tour)</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">LANGUAGE GUIDE</h3><ul><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter3.html">기초 다지기 (The Basics)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter4.html">기본 연산자 (Basic Operators)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter5.html">문자열과 문자 (Strings and Characters)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter6.html">컬렉션 타입 (Collection Types)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter7.html">흐름 제어  (Control Flow)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter8.html">함수 (Functions)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter9.html">클로저 (Closures)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter10.html">열거형 (Enumerations)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter11.html">클래스와 구조체 (Classes and Structures)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter12.html">속성 (Properties)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter13.html">메서드 (Methods)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter14.html">서브스크립트 (Subscripts)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter15.html">상속 (Inheritance)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter16.html">초기화 (Intialization)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter17.html">해제 (Deinitialization)</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/Swift-Korean/docs/chapter18.html">자동 참조 계수 (Automatic Reference Counting)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter19.html">옵셔널 체인 (Optional Chaining)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter20.html">타입 변환 (Type Casting)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter21.html">중첩 타입 (Nested Types )</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter22.html">확장 (Extensions)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter23.html">프로토콜</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter24.html">제네릭스 (Generics)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter25.html">고급 연산자 (Advanced Operators)</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">LANGUAGE REFERENCE</h3><ul><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter26.html">언어 레퍼런스에 대하여 (About the Language Reference)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter27.html">언어 구조 (Lexcial Structure)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter28.html">타입 (Types)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter29.html">익스프레션 (Expressions)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter30.html">스테이트먼트 (Statements)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter31.html">선언 (Declarations)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter32.html">속성 (Attributes)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter33.html">패턴 (Patterns)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter34.html">제너릭 매개변수와 인자 (Generic Parameters and Arguments)</a></li><li class="navListItem"><a class="navItem" href="/Swift-Korean/docs/chapter35.html">문법 요약(Summary of the Grammar)</a></li></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">자동 참조 계수 (Automatic Reference Counting)</h1></header><article><div><span><blockquote>
<p>Translator : Quartet ( <a href="mailto:ungsik.yun@gmail.com">ungsik.yun@gmail.com</a> )</p>
</blockquote>
<p>스위프트는 앱의 메모리 사용량을 추척, 관리하기 위해 자동 참조 계수(ARC)를 사용합니다. 대부분의 경우, 이러한 메모리 관리는 스위프트에서 &quot;그냥 잘 작동합니다&quot;. 개발자가 메모리 관리에 대해서 생각할 필요가 없다는 것이죠. ARC는 인스턴스가 더이상 필요가 없을때 해당 클래스 인스턴스가 쓰는 메모리를 자동으로 해제합니다.
하지만 때때로 ARC는 메모리 관리를 하기 위해서 코드 부분들간의 관계 정보를 알아야 할 때가 있습니다. 이번 장은 그러한 상황을 설명하고, 어떻게 ARC가 앱의 메모리 관리를 가능하게 하는지 보여줍니다.</p>
<blockquote>
<p>NOTE
참조 계수는 오직 클래스의 인스턴스에만 적용됩니다. 구조체와 열거형은 값(Value) 타입이며, 참조 타입이 아닙니다. 또한 참조형태로 저장되거나 전달되지 않습니다.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="arc는-어떻게-작동하는가"></a><a href="#arc는-어떻게-작동하는가" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ARC는 어떻게 작동하는가</h2>
<p>클래스의 새 인스턴스를 만들때마다 인스턴스에 대한 정보를 저장하기 위해 ARC는 메모리 덩어리들을 할당합니다. 이 메모리는 인스턴스 타입에 관련된 정보와, 인스턴스와 관련된 저장 속성의 값들을 저장합니다.
그리고 ARC는 더이상 필요하지 않은 인스턴스의 메모리 할당을 해제하여 메모리가 다른 목적으로 이용될 수 있게 합니다. 이로써 클래스 인스턴스가 필요하지 않은 메모리를 차지하고 있는 것을 방지합니다.
하지만 만약 사용중인 인스턴스를  ARC가 할당 해제하면, 해당 인스턴스의 속성에 접근하거나 메소드를 호출하는 것은 불가능해집니다. 사실, 만약 그 인스턴스에 접근하려하면 앱은 크러시(Crash)가 날것입니다.
사용되고 있는 인스턴스가 사라지지 않게 하기 위해 ARC는 얼마나 많은 속성, 상수, 변수들이 각각의 클래스 인스턴스들을 참조하는지 추적합니다. 최소한 하나의 활성화 참조가 있는 이상, ARC는 해당 인스턴스의 할당을 해제하지 않습니다.
이를 가능하게 하기위해, 클래스 인스턴스를 속성, 상수, 변수에 할당할때 해당 속성, 상수, 변수는 해당 인스턴스에 강한 참조(Strong reference)를 합니다. 이 참조는 &quot;강한&quot; 참조라 불리는데, 해당 인스턴스를 강력하게 유지하기 때문입니다. 그리고 이 강한 참조가 남아있는 이상 해당 인스턴스의 할당 해제는 허용되지 않습니다.</p>
<h2><a class="anchor" aria-hidden="true" id="arc-in-action"></a><a href="#arc-in-action" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ARC in Action</h2>
<p>여기 자동 참조 계수가 어떻게 작동하는지에 대한 예제가 있습니다. 이 예제는 <code>name</code> 이라는 저장된 상수 속성을 정의하는 단순한 클래스 <code>Person</code>을 보여줍니다.</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>
    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>) {
        <span class="hljs-keyword">self</span>.name = name
        <span class="hljs-built_in">println</span>(<span class="hljs-string">"<span class="hljs-subst">\(name)</span> is being initialized"</span>)
    }
    <span class="hljs-keyword">deinit</span> {
        <span class="hljs-built_in">println</span>(<span class="hljs-string">"<span class="hljs-subst">\(name)</span> is being deinitialized"</span>)
    }
}
</code></pre>
<p><code>Person</code> 클래스는 <code>name</code> 속성을 설정하고 초기화가 진행중임을 알리는 메시지를 출력하는 이니셜라이져(initializer)를 가지고 있습니다. 또한 <code>Person</code> 클래스는 인스턴스가 할당 해제될 때 메시지를 출력하는 디이니셜라이져(deinitializer)를 갖고 있습니다.
다음 코드 조각들은 <code>Person?</code> 타입의 변수 3개를 정의하고 있습니다. 이 뒤에 <code>Person</code>의 새 인스턴스들의 복수 참조에 사용하기 위한 것입니다. 타입은 <code>Person</code>이 아닌 <code>Person?</code>인 옵셔널(Optional) 타입이기 때문에, 변수들은 자동적으로 <code>nil</code>로 초기화가 되며, 지금은 <code>Person</code> 인스턴스를 참조하지 않습니다.</p>
<pre><code class="hljs"><span class="hljs-keyword">var</span> reference1: Person?
<span class="hljs-keyword">var</span> reference2: Person?
<span class="hljs-keyword">var</span> reference3: Person?
</code></pre>
<p>이제 새로운 <code>Person</code> 인스턴스를 생성하여 변수 3개중에 하나에 할당할 수 있습니다.</p>
<pre><code class="hljs">reference1 = Person(<span class="hljs-name">name</span>: <span class="hljs-string">"John Appleseed"</span>)
// prints <span class="hljs-string">"John Appleseed is being initialized"</span>
</code></pre>
<p><code>&quot;John Appleseed is being initialized&quot;</code>라는 메시지가 <code>Person</code> 클래스의 이니셜라이져가 호출될 때 출력된다는 점에 주의합니다. 이것으로 초기화가 제대로 됐음을 확인할 수 있습니다.
<code>reference1</code> 변수에 <code>Person</code>의 새 인스턴스가 할당 되었기 때문에, <code>reference1</code>과 <code>Person</code> 인스턴스 사이에 강한 참조가 생깁니다. 그리고 최소한 하나의 강한 참조가 있어서 ARC는 <code>Person</code>이 메모리에 유지되는 것과, 할당 해제 되지 않음을 확인 합니다.
만약 같은 <code>Person</code> 인스턴스를 두개 변수에 더 할당하면, 두개의 강한 참조가 더 생깁니다.</p>
<pre><code class="hljs">refere<span class="hljs-symbol">nce2</span> = refere<span class="hljs-symbol">nce1</span>
refere<span class="hljs-symbol">nce3</span> = refere<span class="hljs-symbol">nce1</span>
</code></pre>
<p>이제 하나의 <code>Person</code> 인스턴스에 대한 강한 참조는 3개입니다.
원래의 참조를 포함한 변수들 중에 <code>nil</code>을 2개 할당함으로써 2개의 강한 참조를 부순다면, 하나의 강한 참조가 남게 되며, 여전히 <code>Person</code> 인스턴스는 할당해제 되지 않습니다.</p>
<pre><code class="hljs"><span class="hljs-attr">reference1</span> = nil
<span class="hljs-attr">reference2</span> = nil
</code></pre>
<p>세번째 강한 참조가 사라져 명확하게 <code>Person</code> 인스턴스가 더 이상 사용되지 않기 전까지 ARC는 <code>Person</code> 인스턴스를 할당 해제 하지 않습니다.</p>
<pre><code class="hljs">reference3 = nil
// prints <span class="hljs-string">"John Appleseed is being deinitialized"</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="클래스-인스턴스간의-강한-참조-순환"></a><a href="#클래스-인스턴스간의-강한-참조-순환" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>클래스 인스턴스간의 강한 참조 순환</h2>
<p>위 예제에서 ARC는 생성된 <code>Person</code> 인스턴스의 참조 갯수를 추적하고 해당 <code>Person</code> 인스턴스가 더이상 필요하지 않을때 할당 해제를 합니다.
하지만 <em>절대로</em> 강한 참조의 갯수가 0으로 떨어지지 않게 코드를 작성하는 것이 가능합니다. 두개의 클래스 인스턴스가 서로를 강하게 잡고 있을때 그 현상이 발생합니다. 인스턴스 서로가 서로를 살게끔 유지하는 것이죠. 이를 <em>강한 참조 순환(strong referecne cycle)</em>이라고 합니다.
강한 참조 순환을 풀려면 클래스간의 관계를 강한 참조 대신 약한(weak) 참조나 미소유 참조(unowned references)로 대체해야 합니다. 이 과정은 __Resolving Strong Reference Cycles __에 설명이 되어있습니다. 하지만 강한 참조 순환을 푸는걸 배우기 전에, 어떻게 순환이  생기는지 이해하는것이 좋습니다.
이 예제는 강한 참조 순환이 어떻게 의도치 않게 생기는지 보여줍니다. 이 예제는 아파트 블록과 거기에 사는 사람을 모델링하는 <code>Person</code>과 <code>Apartment</code> 두개의 클래스를 정의합니다.</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>
    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>) { <span class="hljs-keyword">self</span>.name = name }
    <span class="hljs-keyword">var</span> apartment: <span class="hljs-type">Apartment</span>?
    <span class="hljs-keyword">deinit</span> { <span class="hljs-built_in">println</span>(<span class="hljs-string">"<span class="hljs-subst">\(name)</span> is being deinitialized"</span>) }
}
 
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apartment</span> </span>{
    <span class="hljs-keyword">let</span> number: <span class="hljs-type">Int</span>
    <span class="hljs-keyword">init</span>(number: <span class="hljs-type">Int</span>) { <span class="hljs-keyword">self</span>.number = number }
    <span class="hljs-keyword">var</span> tenant: <span class="hljs-type">Person</span>?
    <span class="hljs-keyword">deinit</span> { <span class="hljs-built_in">println</span>(<span class="hljs-string">"Apartment #<span class="hljs-subst">\(number)</span> is being deinitialized"</span>) }
}
</code></pre>
<p>모든 <code>Person</code> 인스턴스는 <code>String</code>타입의 <code>name</code> 속성을 가지고 있고, 추가적으로 <code>apartment</code> 속성을 최초에 <code>nil</code> 값이 할당된 채로 가집니다. <code>apartment</code> 속성은 옵셔널입니다. 어떤 사람은 아파트에 살지 않을 수도 있기 때문입니다.
비슷하게, 모든 <code>Apartment</code> 인스턴스는 <code>Int</code> 타입의 <code>number</code> 속성을 가지고 있고, 추가적으로 최초에 <code>nil</code>이 할당된 <code>tenant</code> 속성을 가지고 있습니다. <code>tenant</code> 속성은 옵셔널입니다. 어떤 아파트는 사람이 살지 않을 수도 있기 때문입니다.
두 클래스 전부 디이니셜라이저를 정의하여 클래스 인스턴스가 디이니셜라이(역주: 혹은 할당 해제) 된다는 사실을 출력하고있습니다. 이로 인해 <code>Person</code>과 <code>Apartment</code> 인스턴스가 기대한대로 할당 해제가 되는걸 볼 수 있습니다.
다음 코드 조각은 <code>john</code>과 <code>number73</code>이라는 변수를 정의하고 있습니다. 이 변수들에 밑의 <code>Apartment</code>와 <code>Person</code> 인스턴스를 설정할겁니다. 두 변수는 옵셔널이기에 초기값으로 <code>nil</code>을 가집니다.</p>
<pre><code class="hljs"><span class="hljs-keyword">var</span> john: Person?
<span class="hljs-keyword">var</span> number73: Apartment?
</code></pre>
<p>이제 <code>Person</code>과 <code>Apartment</code>의 인스턴스를 생성해서 <code>john</code>과 <code>number73</code> 변수에 할당 할 수 있습니다.</p>
<pre><code class="hljs"><span class="hljs-attr">john</span> = Person(name: <span class="hljs-string">"John Appleseed"</span>)
<span class="hljs-attr">number73</span> = Apartment(number: <span class="hljs-number">73</span>)
</code></pre>
<p>두 인스턴스를 생성 후에 할당하여 강한 참조가 어떻게 구성되는지 보여주는 그림입니다. <code>john</code> 변수는 새 <code>Person</code> 인스턴스에 강한 참조를 가지고 있으며 <code>number73</code> 변수는 <code>Apartment</code> 인스턴스에 강한 참조를 가지고 있습니다.
<img src="https://raw.githubusercontent.com/lean-tra/Swift-Korean/master/images/referencecycle01_2x.png" alt="referencecycle01_2x.png"></p>
<p>이제 두 인스턴스를 서로 연결하여 사람(person)이 아파트를 가지고, 아파트가 사람을 가지게 할 수 있습니다. 여기서 느낌표(<code>!</code>)는 <code>john</code>과 <code>number73</code> 인스턴스 안에 저장된 옵셔널(optional) 변수를 드러내어 접근할 수 있게 하는 것입니다. 그렇게 인스턴스의 속성은 다음과 같이 설정 될 수 있습니다.</p>
<pre><code class="hljs">john!<span class="hljs-selector-class">.apartment</span> = number73
number73!<span class="hljs-selector-class">.tenant</span> = john
</code></pre>
<p>여기 그림은 두 인스턴스간에 강한 참조가 어떻게 형성되어있는지를 보여줍니다.
<img src="https://raw.githubusercontent.com/lean-tra/Swift-Korean/master/images/referencecycle02_2x.png" alt="referencecycle02_2x.png"></p>
<p>안타깝게도 이러한 두 인스턴스간의 연결은 서로간의 강한 참조 순환을 발생시킵니다. <code>Person</code> 인스턴스는 <code>Apartment</code> 인스턴스에 대한 강한 참조를 가지고 있고, <code>Apartment</code> 인스턴스는 <code>Person</code> 인스턴스에 대한 강한 참조를 가지게 됩니다. 그러므로 <code>john</code>과 <code>number73</code> 변수만을 이용하여 강한 참조를 없애려할때, 참조 계수는 0으로 떨어지지 않으며 ARC에 의해 인스턴스가 할당해제 되지 않습니다.</p>
<pre><code class="hljs"><span class="hljs-attr">john</span> = nil
<span class="hljs-attr">number73</span> = nil
</code></pre>
<p>두 변수가 <code>nil</code>로 할당 될 때 디이니셜라이저가 호출되지 않았음에 주의하세요. 강한 참조 순환은 <code>Person</code>과 <code>Apartment</code>의 인스턴스가 영원히 할당 해제 되지 않게하여 앱의 메모리 누수(leak)가 일어나게 합니다.
이 그림은 <code>john</code>과 <code>number73</code> 변수가 <code>nil</code> 로 할당 된 후의 강한 참조가 어떻게 되었는지 보여줍니다.
<img src="https://raw.githubusercontent.com/lean-tra/Swift-Korean/master/images/referencecycle03_2x.png" alt="referencecycle03_2x.png"></p>
<p><code>Person</code>과 <code>Apartment</code>간의 강한 참조는 여전히 남아있으며, 깨어질 수 없게 되었습니다.</p>
<h2><a class="anchor" aria-hidden="true" id="클래스-인스턴스간의-강한-참조-순환-해결하기"></a><a href="#클래스-인스턴스간의-강한-참조-순환-해결하기" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>클래스 인스턴스간의 강한 참조 순환 해결하기</h2>
<p>스위프트는 약한 참조와 미소유 참조라는 2가지 방법 제공하여 클래스 속성에서 일어나는 강한 참조 순환을 해결할 수 있게합니다.
약한 참조나 미소유 참조는 참조 순환의 안에 있는 인스턴스가 다른 인스턴스에 대해 강한 참조를 유지할 필요 없이 참조할 수 있게 합니다. 인스턴스는 서로를 강한 참조 없이 참조 할 수 있게 됩니다.
약한 참조는 해당 참조가 살아있는 동안 잠시라도 <code>nil</code>이 될때 사용하게 됩니다. 그와 반대로 미소유 참조는 참조가 초기화 과정 중 설정 되고 이후에 절대로 <code>nil</code>이 되지 않음을 알고 있을 때 사용합니다.</p>
<h3><a class="anchor" aria-hidden="true" id="약한-참조"></a><a href="#약한-참조" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>약한 참조</h3>
<p><em>약한 참조</em>는 인스턴스가 다른 인스턴스를 참조하는데 강하게 유지하지 않는 참조이며, 그렇기에 ARC가 참조된 인스턴스를 버리는 것을 멈추게 하지 않습니다. 이로 인해 참조가 강한 참조 순환의 일부가 되는 것을 방지합니다. <code>weak</code> 키워드를 선언의 앞에 위치시키는 것으로 속성이나 변수 선언이 약한 참조라고 알릴 수 있습니다.
약한 참조는 참조가 어느 순간 &quot;값 없음&quot;을 참조하게 될때 사용되어 참조 순환을 피하는데 이용 됩니다. 만약 참조가 언제나 값을 가진다면 <strong>미소유 참조</strong>에 설명된 것처럼 미소유 참조를 대신 사용하면 됩니다. 위의 <code>Apartment</code> 예제에서는 아파트가 &quot;거주자 없음&quot; 상태를 가지는 것이 자연스럽기에 약한 참조를 사용하여 참조 순환을 부술 수 있습니다.</p>
<blockquote>
<p>NOTE
약한 참조는 실행 시간중에 값이 바뀔 수 있기 때문에 반드시 변수로서 선언되어야 합니다. 약한 참조는 상수로 선언될 수 없습니다.</p>
</blockquote>
<p>약한 참조는 &quot;값 없음&quot;을 가지는게 허용되기에, 약한 참조는 언제나 옵셔널 타입으로 선언되어야 합니다. 옵셔널 타입은 스위프트에서 &quot;값 없음&quot;을 표현하는데 선호되는 방식입니다.
약한 참조는 인스턴스를 강하게 참조 하고 있지 않기 때문에 약한 참조를 통해 참조를 하고 있는 동안 할당 해제가 될 가능성이 있습니다. 때문에 ARC는 약한 참조가 참조하고 있던 인스턴스가 할당 해제 되면 참조를 자동으로 <code>nil</code>로 설정합니다. 다른 옵셔널 값들처럼, 약한 참조의 값이 존재하는지를 체크할 수 있습니다. 그렇기 때문에 존재하지 않는 잘못된 인스턴스를 참조하는 일은 일어나지 않습니다. (역주: 아예 <code>nil</code>을 참조하는 것과, 있어야 할 자리에 엉뚱한게 있는 것을 참조 하는 것이 다르기에 위의 문장이 나온듯 싶습니다. C에서 포인터를 이용해 강제로 다른 부분을 읽는 것을 생각하면 될것 같습니다.)
밑의 예제는 위의 예제와 똑같지만 중요한 한가지가 다른 <code>Person</code>과 <code>Apartment</code>입니다. 이번에는 <code>Apartment</code> 타입의 <code>tenant</code> 속성이 약한 참조로 선언되어 있습니다.</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>
    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>) { <span class="hljs-keyword">self</span>.name = name }
    <span class="hljs-keyword">var</span> apartment: <span class="hljs-type">Apartment</span>?
    <span class="hljs-keyword">deinit</span> { <span class="hljs-built_in">println</span>(<span class="hljs-string">"<span class="hljs-subst">\(name)</span> is being deinitialized"</span>) }
}
 
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apartment</span> </span>{
    <span class="hljs-keyword">let</span> number: <span class="hljs-type">Int</span>
    <span class="hljs-keyword">init</span>(number: <span class="hljs-type">Int</span>) { <span class="hljs-keyword">self</span>.number = number }
    <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> tenant: <span class="hljs-type">Person</span>?
    <span class="hljs-keyword">deinit</span> { <span class="hljs-built_in">println</span>(<span class="hljs-string">"Apartment #<span class="hljs-subst">\(number)</span> is being deinitialized"</span>) }
}
</code></pre>
<p><code>john</code>과 <code>number73</code> 두 변수의 강한 참조와 두 인스턴스간의 연결은 이전엔 다음과 같았습니다.</p>
<pre><code class="hljs">var <span class="hljs-string">john:</span> Person?
var number73: Apartment?
 
john = Person(name: <span class="hljs-string">"John Appleseed"</span>)
number73 = Apartment(<span class="hljs-string">number:</span> <span class="hljs-number">73</span>)
 
john!.apartment = number73
number73!.tenant = john
</code></pre>
<p>이 그림은 두 인스턴스의 현재 참조가 어떤지를 보여줍니다.
<img src="https://raw.githubusercontent.com/lean-tra/Swift-Korean/master/images/weakreference01_2x.png" alt="weakreference01_2x.png"></p>
<p><code>Person</code> 인스턴스는 여전히 <code>Apartment</code> 인스턴스를 강한 참조로 하고 있습니다. 하지만 <code>Apartment</code> 인스턴스는 이제 <code>Person</code>에 대해 <em>약한 참조</em>를 하고 있습니다. 이는 곧 <code>john</code> 변수에 대한 강한 참조를 없앴을때, <code>Person</code>인스턴스에 대한 강한 참조가 없다는 것을 뜻합니다.
<img src="https://raw.githubusercontent.com/lean-tra/Swift-Korean/master/images/weakreference02_2x.png" alt="weakreference02_2x.png"></p>
<p><code>Person</code> 인스턴스에 대한 강한 참조가 더이상 없기에 인스턴스는 할당해제 됩니다.</p>
<pre><code class="hljs">john = nil
// prints <span class="hljs-string">"John Appleseed is being deinitialized"</span>
</code></pre>
<p><code>Apartment</code> 인스턴스에 대한 강한 참조는 <code>number73</code> 변수에 대한 것밖에 남지 않았습니다. 그 강한 참조를 사라지게 한다면 <code>Apartment</code>에 대한 강한 참조는 더이상 남아있지 않게 됩니다.
<img src="https://raw.githubusercontent.com/lean-tra/Swift-Korean/master/images/weakreference03_2x.png" alt="weakreference03_2x.png"></p>
<p><code>Apartment</code>에 대한 강한 참조가 더이상 없기 때문에, 이 인스턴스 역시 할당 해제 됩니다.</p>
<pre><code class="hljs">number73 = nil
// prints <span class="hljs-string">"Apartment #73 is being deinitialized"</span>
</code></pre>
<p>위 두 코드 조각은 <code>Person</code>과 <code>Apartment</code>의 디이니셜라이저가 <code>john</code>과 <code>number73</code> 변수가 <code>nil</code>로 설정 될때 &quot;디이니셜라이즈&quot; 메시지를 출력하는 것을 보여줍니다. 이것으로 강한 참조가 사라졌을음 증명할 수 있습니다.</p>
<h3><a class="anchor" aria-hidden="true" id="미소유-참조"></a><a href="#미소유-참조" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>미소유 참조</h3>
<p>약한 참조처럼 <em>미소유 참조</em> 또한 인스턴스에 대한 참조를 강하게 하지 않습니다. 약한 참조와는 다르게, 미소유 참조는 언제나 값을 가지고 있다고 간주합니다. 이 때문에 미소유 참조는 옵셔널 타입이 아닙니다(non-optional). 미소유 참조는 <code>unowned</code>  키워드를 속성이나 변수 선언 앞에 위치 시킴으로써 할 수 있습니다.
미소유 참조는 옵셔널이 아니기 때문에 미소유 참조를 쓸 때마다 드러내야 할 필요가 없습니다. 미소유 참조는 언제나 직접 접근이 가능합니다. 하지만 ARC가 인스턴스의 참조를 할당 해제 할 때 <code>nil</code>로 설정 할 수는 없습니다. 옵셔널이 아닌 타입은 <code>nil</code>로 설정 될 수 없기 때문입니다.</p>
<blockquote>
<p>NOTE
만약 미소유 참조가 참조하는 인스턴스가 할당 해제된 후에 접근하려 한다면 런타임 에러를 발생 시킬것입니다. 미소유 참조는 언제나 인스턴스를 참조하는 게 확실할 때에만 사용해야 합니다.
스위프트는 미소유 참조가 할당 해제된 인스턴스에 접근하려 할때 언제나 크래시를 낸다는 것에 주의하십시오. 앱은 언제나 안정적으로 크래시할 것입니다. 물론, 당연히 그런 일이 일어나지 않게 해야할테지만 말이죠.</p>
</blockquote>
<p>다음의 예제는 <code>Customer</code>와 <code>CreditCard</code> 두 클래스를 정의하고 있습니다. 이 클래스는 은행 고객과 그 고객에게 가능한 신용카드를 모델링합니다. 이 두 클래스는 서로의 인스턴스를 속성으로 저장합니다. 이 관계는 강한 참조 순환을 만들 가능성이 있습니다.
<code>Customer</code>와 <code>CreditCard</code> 의 관계는 위의 약한 참조 예제에서 살펴본  <code>Person</code>과 <code>Apartment</code>의 관계와는 조금 다릅니다. 이 데이터 모델에서  고객은 신용 카드를 가질수도 있고 안가질수도 있습니다. 하지만 신용 카드는 <em>언제나</em> 고객과 연관이 됩니다. 그것을 표현하기 위해 <code>Customer</code> 클래스는 <code>card</code> 속성을 옵셔널 로 가지지만, <code>CredicCard</code> 클래스는 <code>customer</code> 를 논옵셔널(non-optional) 속성으로 가집니다.
게다가 새로운 <code>CreditCard</code> 인스턴스는 오직 <code>number</code>값과 <code>customer</code> 인스턴스를 <code>CreditCard</code>의 맞춤(custom) 이니셜라이저를 통해서만 생성될 수 있습니다. 이를 통해 <code>CreditCard</code> 인스턴스가 생성될 때는 언제나 <code>credit</code> 인스턴스와 연관이 됨을 보증할 수 있습니다.
신용카드는 언제나 고객을 가지기 때문에 <code>customer</code> 속성을 미소유 참조로 설정하여 강한 참조 순환을 피할 수 있습니다.</p>
<pre><code class="hljs">class<span class="hljs-built_in"> Customer </span>{
    let name: String
    var card: CreditCard?
    init(name: String) {
        self.name = name
    }
    deinit { println(<span class="hljs-string">"\(name) is being deinitialized"</span>) }
}
 
class CreditCard {
    let number: Int
    unowned let customer:<span class="hljs-built_in"> Customer
</span>    init(number: Int, customer: Customer) {
        self.number = number
        self.customer =<span class="hljs-built_in"> customer
</span>    }
    deinit { println(<span class="hljs-string">"Card #\(number) is being deinitialized"</span>) }
}
</code></pre>
<p>다음 코드 조각은 옵셔널 <code>Customer</code> 변수인 <code>john</code>을 정의하여 특정한 고객의 정보를 참조하게 하였습니다. 이 변수는 옵셔널 변수임으로 <code>nil</code>을 초기값으로 갖습니다.</p>
<pre><code class="hljs"><span class="hljs-keyword">var</span> john: Customer?
</code></pre>
<p>이제 <code>Customer</code> 인스턴스를 생성하여 인스턴스의 <code>card</code> 속성에 할당할 <code>CreditCard</code> 인스터스의 초기화에 이용할 수 있습다.</p>
<pre><code class="hljs">john = Customer(<span class="hljs-string">name:</span> <span class="hljs-string">"John Appleseed"</span>)
john!.card = CreditCard(<span class="hljs-string">number:</span> <span class="hljs-number">1234</span>_5678_9012_3456, <span class="hljs-string">customer:</span> john!)
</code></pre>
<p>이 그림은 위 두 인스턴스간의 관계가 어떻게 되는지 보여주고 있습니다.
<img src="https://raw.githubusercontent.com/lean-tra/Swift-Korean/master/images/unownedreference01_2x.png" alt="unownedreference01_2x.png"></p>
<p><code>Customer</code> 인스턴스는 <code>CreditCard</code>에 대해 강한 참조를 하고 있습니다. <code>CreditCard</code>는 <code>Customer</code> 인스턴스에 대해 미소유 참조를 하고 있습니다.
<code>customer</code>가 미소유 참조이기 때문에 <code>john</code> 변수에 한 강한 참조를 사라지게 한 순간, <code>Customer</code>에 대한 강한 참조는 더이상 존재않게 됩니다.
<img src="https://raw.githubusercontent.com/lean-tra/Swift-Korean/master/images/unownedreference02_2x.png" alt="unownedreference02_2x.png"></p>
<p><code>Customer</code> 인스턴스에 대한 강한 참조가 더이상 존재하지 않게되어 인스턴스는 할당 해제 됩니다. 이 일이 일어난 뒤에, <code>CreditCard</code> 인스턴스에 대한 강한 참조 역시 더이상 존재하지 않기에 이 또한 할당 해제 됩니다.</p>
<pre><code class="hljs">john = nil
<span class="hljs-regexp">//</span> prints <span class="hljs-string">"John Appleseed is being deinitialized"</span>
<span class="hljs-regexp">//</span> prints <span class="hljs-string">"Card #1234567890123456 is being deinitialized"</span>
</code></pre>
<p>위에 있는 마지막 코드 조각은 <code>john</code>변수가 <code>nil</code>로 설정 된 후 <code>Customer</code> 인스턴스와 <code>CreditCard</code> 인스턴스가 둘 다 &quot;디이니셜라이즈&quot; 메시지를 출력하는 것을 보여주고 있습니다.</p>
<h3><a class="anchor" aria-hidden="true" id="미소유-참조와-암시적으로implicitly-드러난unwrapped-옵셔널-속성"></a><a href="#미소유-참조와-암시적으로implicitly-드러난unwrapped-옵셔널-속성" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>미소유 참조와 암시적으로(implicitly) 드러난(unwrapped) 옵셔널 속성</h3>
<p>위의 약한 참조와 미소유 참조에 대한 예제는 일반적으로 강한 참조 순환을 부술 필요가 있는 시나리오중 2개를 보여주고 있습니다.
<code>Person</code>과 <code>Apartment</code> 예제는 두 쪽의 속성이 <code>nil</code>이 될 수도 있는 상황에서 강한 참조 순환의 가능성이 있는 상황 이었습니다. 이 시나리오는 약한 참조로 훌륭하게 해결 됩니다.
<code>Customer</code>와 <code>CreditCard</code> 예제는 한 쪽의 속성이 <code>nil</code>이 될 수 있고, 다른 쪽 속성은 <code>nil</code>이 되지 않을때 강한 참조 순환이 생길 수 있는 상황 이었습니다. 이 시나리오는 미소유 참조로 훌륭하게 해결됩니다.
하지만 여기에 세번째 시나리오가 있습니다. <em>양 쪽</em>의 속성이 모두 언제나 값을 가져야 하며, 속성은 초기화 완료 이후에 <code>nil</code> 이 되면 안되는 시나리오입니다.  이 시나리오에서는 한쪽 클래스의 미소유 속성과 다른 쪽 클래스의 암시적으로 드러난 옵셔널 속성이 유용합니다.
이는 양쪽의 속성이 초기화가 한번 완료된 이후에 옵셔널 속성을 드러낼 필요 없이 직접 접근이 될 수 있게 하며, 참조 순환이 일어나지 않게 합니다. 이번 섹션(section)은 이런 관계를 어떻게 설정하는지 보일 것입니다.
밑의 예제는 두개의 클래스 <code>Country</code>와 <code>City</code>를 정의합니다. 각각의 클래스는 서로의 클래스 인스턴스를 속성으로 저장합니다. 이 데이터 모델에서, 모든 나라들은 언제나 수도를 가지며, 모든 도시는 반드시 나라에 소속되어야합니다. 이를 표현하기 위해서 <code>Country</code>는 <code>capitalCity</code>속성을 가지고, <code>City</code> 클래스는 <code>country</code> 속성을 가집니다.</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Country</span> </span>{
    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>
    <span class="hljs-keyword">let</span> capitalCity: <span class="hljs-type">City</span>!
    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>, capitalName: <span class="hljs-type">String</span>) {
        <span class="hljs-keyword">self</span>.name = name
        <span class="hljs-keyword">self</span>.capitalCity = <span class="hljs-type">City</span>(name: capitalName, country: <span class="hljs-keyword">self</span>)
    }
}
 
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">City</span> </span>{
    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>
    <span class="hljs-keyword">unowned</span> <span class="hljs-keyword">let</span> country: <span class="hljs-type">Country</span>
    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>, country: <span class="hljs-type">Country</span>) {
        <span class="hljs-keyword">self</span>.name = name
        <span class="hljs-keyword">self</span>.country = country
    }
}
</code></pre>
<p>양 클래스 간의 상호 의존성을 설정하기 위해 <code>City</code> 이니셜라이저는 <code>Country</code> 인스턴스를 입력받고, 이 인스턴스를 <code>country</code> 속성에 저장합니다.
<code>City</code>의 이니셜라이저는 <code>Country</code> 이니셜라이저 안에서 호출됩니다. 하지만 <code>Country</code> 이니셜라이저는 새 <code>Country</code> 인스턴스가 완전하게 이니셜라이즈 되기 전까지 <code>self</code>를 <code>City</code>로 넘길 수 없습니다. <strong>이 단계 초기화</strong> 에서 설명된 것처럼 말이죠.
이 요구에 대처하기 위해  <code>Country</code>의 <code>capitalCity</code> 속성을 암시적으로 드러난 옵셔널 속성으로 선언합니다. 그러기 위해서 타입 표시의 끝에 느낌표를 붙이면 됩니다(<code>City!</code>). 이는 <code>capitalCity</code>가 다른 옵셔널 값들처럼 <code>nil</code>을 기본값으로 가짐을 뜻하지만, <strong>암시적으로 드러난 옵셔널</strong>에서 설명한 것과 같이 접근하는데 드러내야할 필요가 없습니다.
<code>capitalCity</code>가 기본값으로 <code>nil</code>을 가지기에, 새 <code>Country</code> 인스턴스는 <code>Country</code> 인스턴스의 <code>name</code> 속성이 이니셜라이저 안에서 설정 되었을때를 완전히 완전히 초기화 된 순간이라고 간주합니다. 이는 <code>Country</code> 이니셜라이저가 암시적으로 <code>name</code>속성이 설정 되는 순간부터 <code>self</code> 속성을 참조하고 넘겨줄 수 있다는 것을 뜻합니다. 그렇기에  <code>Country</code>의 이니셜라이저는 자신의 <code>capitalCity</code> 속성을 설정할때 <code>self</code>를 <code>City</code> 이니셜라이저의 파라메터로 넘겨줄 수 있습니다.
이 모든 것은 강한 참조 순환을 만들지 않고 <code>Country</code>와 <code>City</code> 인스턴스를 한 문장(statement)안에서 만들 수 있다는 것을 뜻합니다. 그리고 느낌표를 통해 옵셔널 값을 드러내지 않고 <code>capitalCity</code> 속성에 직접 접근 할 수 있습니다.</p>
<pre><code class="hljs"><span class="hljs-selector-tag">var</span> country = Country(name: <span class="hljs-string">"Canada"</span>, capitalName: <span class="hljs-string">"Ottawa"</span>)
<span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">"\(country.name)'s capital city is called \(country.capitalCity.name)"</span>)</span></span>
<span class="hljs-comment">// prints "Canada's capital city is called Ottawa"</span>
</code></pre>
<p>위의 예제에서는 암시적으로 드러난 옵셔널은 모든 두 단계의 클래스 이니셜라이저 요구사항이 모두 충족되었다는 것을 뜻합니다. <code>capitalCity</code> 속성에는 초기화 단계가 일단 끝나고 난후에는 옵셔널이 아닌 값처럼 접근이 가능합니다. 여전히 강한 참조 순환을 만들지 않으면서 말이죠.</p>
<h2><a class="anchor" aria-hidden="true" id="클로저를-위한-강한-참조-순환"></a><a href="#클로저를-위한-강한-참조-순환" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>클로저를 위한 강한 참조 순환</h2>
<p>위에서 어떻게 두 클래스 인스턴스의 속성들이 서로 강한 참조를 하면서 강한 참조 순환을 만드는지 보았습니다. 또한 약한 참조와 미소유 참조를 이용해 어떻게 강한 참조 순환을 부수는지도 보았습니다.
클로저를 클래스 인스턴스의 속성에 할당할때도 강한 참조 순환이 발생할 수 있습니다. 해당 클로저의 몸체는 인스턴스를 획득(capture)합니다. 이 획득은 클로저의 몸체가 <code>self.someProperty</code>와 같은인스턴스의 속성에 접근하려 할 때 발생합니다. 혹은 클로저가 <code>self.someMethod()</code>와 같은 인스턴스의 메소드를 호출 할 때도 발생합니다. 어느 경우든간에 그러한 접근에서 클로저는 <code>self</code>를 획득하게 되며, 강한 참조 순환을 만들어냅니다.
이 강한 참조 순환은 클로저가 클래스와 같이 <em>참조 타입</em> 이기 떄문에 일어납니다. 클로저를 속성에 할당하면, <em>참조</em>를 클로저에 할당하는 것이 됩니다. 본질적으로, 이는 위에서 말한 문제와 같은 문제입니다. 두개의 강한 참조가 서로를 살아있게 만듭니다. 하지만 이번엔 두개의 클래스 인스턴스가 아니라, 하나의 클래스 인스턴스와 클로저가 서로를 살아있게 합니다.
스위프트는 이 문제에 대해  <em>클로저 획득 목록</em>이라는 우아한 방법을 제공합니다. 하지만 클로저 획득 목록을 이용하여 강한 참조 순환을 부수는 방법을 배우기 전에, 어떻게 순환이 야기되는지 이해하는 것이 좋습니다.
밑의 예제는 <code>self</code>를 클로저가 참조하면서 어떻게 강한 참조 순환이 생겨나는지 보여줍니다. 이 예제는<code>HTMLElement</code> 클래스를 정의해서 HTML 문서와 그 안에 포함된 개개의 요소를 모델링하고 있습니다.</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HTMLElement</span> </span>{
    
    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>
    <span class="hljs-keyword">let</span> text: <span class="hljs-type">String</span>?
    
    <span class="hljs-meta">@lazy</span> <span class="hljs-keyword">var</span> asHTML: () -&gt; <span class="hljs-type">String</span> = {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> text = <span class="hljs-keyword">self</span>.text {
            <span class="hljs-keyword">return</span> <span class="hljs-string">"&lt;<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.name)</span>&gt;<span class="hljs-subst">\(text)</span>&lt;/<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.name)</span>&gt;"</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-string">"&lt;<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.name)</span> /&gt;"</span>
        }
    }
    
    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>, text: <span class="hljs-type">String</span>? = <span class="hljs-literal">nil</span>) {
        <span class="hljs-keyword">self</span>.name = name
        <span class="hljs-keyword">self</span>.text = text
    }
    
    <span class="hljs-keyword">deinit</span> {
        <span class="hljs-built_in">println</span>(<span class="hljs-string">"<span class="hljs-subst">\(name)</span> is being deinitialized"</span>)
    }
    
}
</code></pre>
<p><code>HTMLElement</code> 클래스는 <code>name</code> 속성을 정의하여 요소의 이름을 가리키고 있습니다. 문단 요소인 <code>&quot;p&quot;</code>나 줄바꿈 요소인 <code>&quot;br&quot;</code>등. <code>HTMLElement</code>는 또한 <code>text</code> 속성을 정의하여 HTML 속성내에서 텍스트가 설정되어서 보일 수 있게 합니다.
그런 간단한 두 속성 외에 <code>HTMLElement</code>는 <code>asHTML</code>이라는 느린(lazy) 속성을 정의합니다. 이 속성은 HTML 문자열 조각 안에 있는 <code>name</code>과 <code>text</code> 조합된것을 참조합니다. <code>asHTML</code> 속성의 타입은 <code>() -&gt; String</code>이며, 다른 말로는 &quot; 파라메터를 받지않고, <code>String</code> 값을 반환하는 함수&quot; 라 할 수 있습니다.
기본적으로 <code>asHTML</code> 속성은 HTML태그의 문자열 표현을 반환하는 클로저에 할당되어있습니다. 이 태그는 옵셔널인 <code>text</code>값이 존재할 경우 그것을 포함하게 되며, <code>text</code>가 존재하지 않을때는 아무런 텍스트 내용을 가지지 않습니다. 문단 요소에 대해 이 클로저는 <code>text</code> 속성이 <code>&quot;some text&quot;</code>나 <code>nil</code>중 어느것에 해당하는지에 따라서 <code>&lt;p&gt;some text&lt;/p&gt;</code>를 반환하거나 <code>&lt;p /&gt;</code>를 반환합니다.
이 <code>asHTML</code>은 인스턴스 메소드와 비슷한 것처럼 이름 지어지고, 사용됩니다. 하지만 <code>asHTML</code>은 인스턴스 메소드가 아닌 클로저 속성이기에, 특정 HTML 요소에 대해 HTML 렌더링을 바꾸고 싶다면 기본값을 대체하여 맞춤(custom) 클로저로 바꿀 수 있습니다.</p>
<blockquote>
<p>NOTE
이 <code>asHTML</code> 속성은 느린(lazy) 속성으로 선언되어 있습니다. 특정 HTML 출력 목표에 대해 문자열 값을 렌더링해야할 필요가 있을때만 필요해지기 때문입니다. <code>asHTML</code>이 느림 속성이기 때문에 <code>self</code>를 기본 클로저 안에서 참조할 수 있습니다. 느린 속성은 초기화가 완료 되어 <code>self</code>가 존재하기 전까지는 접근이 되지 않기 때문입니다.</p>
</blockquote>
<p><code>HTMLElement</code> 클래스는 하나의 이니셜라이저를 제공하여 <code>name</code> 인자와 필요하다면 <code>text</code> 인자를 받아 새 요소를 초기화합니다. 또한 이 클래스는 디이니셜라이저를 정의하여 <code>HTMLElement</code>가 할당 해제 될 때 메시지를 출력하게 합니다.
여기 <code>HTMLElement</code> 클래스를 생성하여 새 인스턴스가 어떻게 출력을 하는지 예제가 있습니다.</p>
<pre><code class="hljs">var <span class="hljs-string">paragraph:</span> HTMLElement? = HTMLElement(name: <span class="hljs-string">"p"</span>, <span class="hljs-string">text:</span> <span class="hljs-string">"hello, world"</span>)
println(paragraph!.asHTML())
<span class="hljs-comment">// prints "&lt;p&gt;hello, world&lt;/p&gt;"</span>
</code></pre>
<blockquote>
<p>NOTE
위의 <code>paragraph</code> 변수는 옵셔널 <code>HTMLElement</code>로 정의되어있습니다. 그래서 아래에서 <code>nil</code>로 설정되면 강한 참조 순환이 존재하게 됨을 보일 수 있습니다.</p>
</blockquote>
<p>안타깝게도, 위에 쓰여진대로 <code>HTMLElement</code> 클래스는 <code>HTMLElement</code> 인스턴스와 <code>asHTML</code>의 기본값으로 설정된 클로저 사이에 강한 참조 순환을 만들게 되었습니다. 그림은 그 순환이 어떻게 생겼는지 보여줍니다.
<img src="https://raw.githubusercontent.com/lean-tra/Swift-Korean/master/images/closurereferencecycle01_2x.png" alt="closurereferencecycle01_2x.png"></p>
<p>인스턴스의 <code>asHTML</code> 속성은 해당 클로저에 대해 강한 참조를 하고 있습니다. 하지만 클로저가 그 몸체 안에서 <code>self.name</code>과 <code>self.text</code>를 참조하는 방법으로 <code>self</code>를 참조하고 있기에 클로저는 인스턴스 자신을(slef) <em>획득</em>하게 됩니다.  즉 <code>HTMLElement</code> 인스턴스를 참조하게 되어 강한 참조를 하게 됩니다. 이렇게 둘 사이에 강한 참조 순환이 형성되게 됩니다. (클로저의 값 획득에 대해서 더 자세한 정보는 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-XID_129">값 획득</a>을 보세요)</p>
<blockquote>
<p>NOTE
클로저가 <code>self</code>를 여러번 참조한다고 해도, <code>HTMLElement</code>에 대한 강한 참조는 오직 한번만 획득하게 됩니다.</p>
</blockquote>
<p>만약 <code>paragraph</code> 변수를 <code>nil</code>로 설정하고, 이 <code>HTMLElement</code>에 대한 강한 참조를 부순다면, <code>HTMLElement</code> 인스턴스나 그 클로저는 할당 해제되지 않습니다. 강한 참조 순환이 있기 때문입니다.</p>
<pre><code class="hljs"><span class="hljs-attr">paragraph</span> = nil
</code></pre>
<p><code>HTMLElement</code>의 디이니셜라이저가 아무런 메시지도 출력하지 않았음에 주의하세요. 이는 곧  <code>HTMLElement</code> 인스턴스가 할당 해제 되지 않았음을 의미합니다.</p>
<h2><a class="anchor" aria-hidden="true" id="클로저의-강한-참조-순환-해결하기"></a><a href="#클로저의-강한-참조-순환-해결하기" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>클로저의 강한 참조 순환 해결하기.</h2>
<p>클로저와 클래스의 강한 참조 순환은 클로저 정의의 일부로서 <em>획득 목록</em>을 정의하는 것으로 해결 할 수 있습니다. 획득 목록은 하나 이상의 참조 타입이 클로저의 몸체에 있을때 사용할 규칙을 정의합니다. 두 클래스 인스턴스 간의 강한 참조 순환 처럼, 획득한 참조를 강한 참조대신 약한 참조나 미소유 참조로 선언할 수 있습니다. 약한 참조나 미소유 참조중 어느 것이 더 적절한지는 코드의 다른 부분에 따라 다릅니다.</p>
<blockquote>
<p>NOTE
스위프트는 <code>self</code>의 멤버를 클로저 안에서 참조할때 <code>someProperty</code>나 <code>someMethod</code> 대신에 <code>self.someProperty</code>나 <code>self.someMethod</code>로 표기할 것을 요구합니다. 이렇게 함으로써 <code>self</code>가 의도치 않게 획득 될 수 있음을 기억하는데 도움이 됩니다.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="획득-목록-정의하기"></a><a href="#획득-목록-정의하기" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>획득 목록 정의하기</h3>
<p>획득 목록의 각각의 아이템은 <code>self</code>나 <code>someInstance</code>같은 클래스 인스턴스와 참조간의 약한 참조 또는 미소유 참조의 쌍입니다. 각 쌍들은 대괄호안에 쓰여지며, 콤마로 구분됩니다.</p>
<p>획득 목록은 클로저에 파라메터 목록이나 반환 타입이 있다면 그 앞에 위치시킵니다.</p>
<pre><code class="hljs">@lazy <span class="hljs-keyword">var</span> someClosure: <span class="hljs-function"><span class="hljs-params">(Int, String)</span> -&gt;</span> String = {
    [unowned self] <span class="hljs-function"><span class="hljs-params">(index: Int, stringToProcess: String)</span> -&gt;</span> String <span class="hljs-keyword">in</span>
    <span class="hljs-regexp">// closure body goes here
}
</span></code></pre>
<p>만약 클로저의 파라메터 목록이나 반환 타입이 문맥에서 암시되어 특별히 정해지지 않았다면, 획득 목록은 클로저의 시작 부분인 <code>in</code> 바로 앞에 둡니다.</p>
<pre><code class="hljs">@lazy <span class="hljs-keyword">var</span> someClosure: <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> String = {
    [unowned self] <span class="hljs-keyword">in</span>
    <span class="hljs-regexp">// closure body goes here
}
</span></code></pre>
<h3><a class="anchor" aria-hidden="true" id="약한-참조와-미소유-참조"></a><a href="#약한-참조와-미소유-참조" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>약한 참조와 미소유 참조</h3>
<p>클로저와 클로저가 획득한 인스턴스가 언제나 서로를 참조할때, 획득을 미소유 참조로 정의합니다. 그렇게 되면 같은 시점에 서로 할당 해제가 될것입니다.
그와 반대로, 클로저가 획득한 참조가 언젠가는 <code>nil</code>이 될때, 획득을 약한 참조로 정의합니다. 약한 참조는 언제나 옵셔널 타입이며, 참조중인 인스턴스가 할당 해제가 되면 자동적으로 <code>nil</code>이 됩니다. 이로 인해 클로저 몸체에서 인스턴스의 존재를 확인할 수 있습니다.</p>
<blockquote>
<p>NOTE
만약 획득된 참조가 절대로 <code>nil</code>이 되지 않는다면, 그 참조는 약한 참조보다 미소유 참조로 해야할것입니다.</p>
</blockquote>
<p>미소유 참조는 위의 <code>HTMLElement</code> 예제에서 강한 참조 순환을 풀기에 적절한 획득 방법입니다. 다음은 <code>HTMLElement</code> 클래스가 순환을 어떻게 피해야 할지 보여줍니다.</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HTMLElement</span> </span>{
    
    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>
    <span class="hljs-keyword">let</span> text: <span class="hljs-type">String</span>?
    
    <span class="hljs-meta">@lazy</span> <span class="hljs-keyword">var</span> asHTML: () -&gt; <span class="hljs-type">String</span> = {
        [<span class="hljs-keyword">unowned</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> text = <span class="hljs-keyword">self</span>.text {
            <span class="hljs-keyword">return</span> <span class="hljs-string">"&lt;<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.name)</span>&gt;<span class="hljs-subst">\(text)</span>&lt;/<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.name)</span>&gt;"</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-string">"&lt;<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.name)</span> /&gt;"</span>
        }
    }
    
    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>, text: <span class="hljs-type">String</span>? = <span class="hljs-literal">nil</span>) {
        <span class="hljs-keyword">self</span>.name = name
        <span class="hljs-keyword">self</span>.text = text
    }
    
    <span class="hljs-keyword">deinit</span> {
        <span class="hljs-built_in">println</span>(<span class="hljs-string">"<span class="hljs-subst">\(name)</span> is being deinitialized"</span>)
    }
    
}
</code></pre>
<p>위의 <code>HTMLElement</code> 구현은 이전의 구현과 동일합니다. <code>asHTML</code> 클로저의 획득 목록 부분을 제외하면 말이죠. 이 경우에 획득 목록은 <code>[unowned self],</code>며, 이는 &quot;인스턴스를 강한 참조가 아닌 미소유 참조로서 획득한다&quot;라 할 수 있습니다.</p>
<p>이제 이전처럼 <code>HTMLElement</code> 인스턴스를 생성하여 출력할 수 있습니다.</p>
<pre><code class="hljs">var <span class="hljs-string">paragraph:</span> HTMLElement? = HTMLElement(name: <span class="hljs-string">"p"</span>, <span class="hljs-string">text:</span> <span class="hljs-string">"hello, world"</span>)
println(paragraph!.asHTML())
<span class="hljs-comment">// prints "&lt;p&gt;hello, world&lt;/p&gt;"</span>
</code></pre>
<p>이 그림은  획득 목록을 사용한 참조들이 어떻게 보여줍니다.
<img src="https://raw.githubusercontent.com/lean-tra/Swift-Korean/master/images/closurereferencecycle02_2x.png" alt="closurereferencecycle02_2x.png"></p>
<p>이번의 클로저에 의한 <code>self</code> 획득은 미소유 참조입니다. 그렇기에 획득한 <code>HTMLElement</code> 인스턴스를 강하게 유지하지 않습니다. 만약 <code>paragraph</code> 변수의 강한 참조를 <code>nil</code>로 설정한다면, <code>HTMLElement</code> 인스턴스는 할당 해제가 될 것입니다. 밑의 예제에서 보이는 것처럼 디이니셜라이저 메시지를 출력하면서 말이죠.</p>
<pre><code class="hljs">paragraph = nil
// prints <span class="hljs-string">"p is being deinitialized"</span>
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/Swift-Korean/docs/chapter17.html">← 해제 (Deinitialization)</a><a class="docs-next button" href="/Swift-Korean/docs/chapter19.html">옵셔널 체인 (Optional Chaining) →</a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#arc는-어떻게-작동하는가">ARC는 어떻게 작동하는가</a></li><li><a href="#arc-in-action">ARC in Action</a></li><li><a href="#클래스-인스턴스간의-강한-참조-순환">클래스 인스턴스간의 강한 참조 순환</a></li><li><a href="#클래스-인스턴스간의-강한-참조-순환-해결하기">클래스 인스턴스간의 강한 참조 순환 해결하기</a><ul class="toc-headings"><li><a href="#약한-참조">약한 참조</a></li><li><a href="#미소유-참조">미소유 참조</a></li><li><a href="#미소유-참조와-암시적으로implicitly-드러난unwrapped-옵셔널-속성">미소유 참조와 암시적으로(implicitly) 드러난(unwrapped) 옵셔널 속성</a></li></ul></li><li><a href="#클로저를-위한-강한-참조-순환">클로저를 위한 강한 참조 순환</a></li><li><a href="#클로저의-강한-참조-순환-해결하기">클로저의 강한 참조 순환 해결하기.</a><ul class="toc-headings"><li><a href="#획득-목록-정의하기">획득 목록 정의하기</a></li><li><a href="#약한-참조와-미소유-참조">약한 참조와 미소유 참조</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/Swift-Korean/" class="nav-home"><img src="/Swift-Korean/img/docusaurus.svg" alt="Swift 가이드" width="66" height="58"/></a><div><h5>Docs</h5><a href="/Swift-Korean/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/Swift-Korean/docs/en/doc2.html">Guides (or other categories)</a><a href="/Swift-Korean/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/Swift-Korean/en/users.html">User Showcase</a><a href="http://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/Swift-Korean/blog">Blog</a><a href="https://github.com/">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/Swift-Korean/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2018 Your Name or Your Company Name</section></footer></div></body></html>